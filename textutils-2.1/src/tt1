   ' to STDOUT_FILENO.                 Copies the file behind `input_desc
   ';/      /*bpout++ = '?';       }   else       {         *bpout++ = 'M
   '\n/     */         bpin = inbuf;   eob = bpin + n_read;        *eob =
   --/    /which version of `cat' to   use. If any options (more than -u,
   -A, --/     /FILE(s), or standard   input, to standard output.\n\ \n\
   -B,/    /input.\n\ "), stdout); #   if O_BINARY       fputs (_("\ \n\
   -b/    /marking lines' ends: then   we use text I/O, because otherwise
   -e, or -t/        */        /* If   quoting, i.e. at least one of -v,
     ', '0',     '\t', '\0'   };  /*   Position in `line_buf' where/   /, '
     't care much about the original   file contents anyway).     /they don
     -1, 1 newline makes NEWLINES 1,   etc.                       /NEWLINES
     -2002 Free Software Foundation,   Inc.             /) 88, 90, 91, 1995
     -b, --number-nonblank    number   nonblank output lines\n\   -e/   /n\
     -e, or -t specified,   scan for   chars that need conversion.     /-v,
     -n, --number             number   all output lines\n\   -s, --/   /\n\
     -show-tabs          display TAB   characters as ^I\n\   -u/     /-T, -
      '\n');        /* Are we at the   beginning of a line, and line/   /==
      '\t';        else if (ch == '\   n')   {     newlines = -1;/    /++ =
      -- concatenate files and print   on the standard output.       /* cat
      - 1 + INSIZE * 4) bytes in the   buffer.            /at most (OUTSIZE
      - 8;  /* Position of the first   digit in `line_buf'.       /_BUF_LEN
      -s and -E would surprise users   on DOS/Windows where a line/    /-b,
      -t specified,   scan for chars   that need conversion.    /-v, -e, or
       ' function's local `newlines'   between invocations.       /the `cat
       - 1) bytes will remain in the   buffer.               /most (OUTSIZE
       - 3;  /* Position of the last   digit in `line_buf'.       /_BUF_LEN
       - wp);      }     /* Is INBUF   empty?            /= outbuf + (bpout
        ' for more information.\n"),   program_name);   else     {/   /help
        '\t', '\0'   };  /* Position   in `line_buf' where printing/   /0',
        'u':    /* We provide the -u   feature unconditionally.       /case
        - 3;  /* Preserves the `cat'   function's local `newlines'/   /_LEN
        -B, --binary             use   binary writes to the console/   /\n\
        -nonblank    number nonblank   output lines\n\   -e/   /b, --number
         's local `newlines' between   invocations.     /the `cat' function
         'u':    /* We provide the -   u feature unconditionally.     /case
         -u,   --version, or --help)   were specified, use `cat',/    /than
          - 1 + INSIZE * 4) bytes in   the buffer.        /at most (OUTSIZE
           - 1) bytes will remain in   the       buffer.     /most (OUTSIZE
                                       Irix-5 returns ENOSYS on pipes.
                                       May be "-".
                                       Now INSIZE bytes of input is read.
                                       Undo that.
                                 May   be "-".
                                 Now   INSIZE bytes of input is read.
                                Undo   that.
                              Irix-5   returns ENOSYS on pipes.
                            */    /*   Main loop.
                          Now INSIZE   bytes of input is read.
                       */         /*   Was the last line empty?
                       */    /* Main   loop.
                       Called if any   option more than -u was specified.
                      Irix-5 returns   ENOSYS on pipes.
                    Now INSIZE bytes   of input is read.
                   (On Ultrix, it is   not supported on NFS filesystems.)
                   */         /* Was   the last line empty?
                   */ char *program_   name;  /* Name of input file.
                   /or FITNESS FOR A   PARTICULAR PURPOSE.
                  */  /* Differences   from the Unix cat:    * Always/
                 Exceptions are when   they request line numbering,/
                 Now INSIZE bytes of   input is read.
                */ static int input_   desc;  /* Buffer for line numbers.
                But we want terminal   reads to be interruptible.
                Called if any option   more than -u was specified.
                Each input character   may grow by a factor of 4 (by the/
                Input   files cannot   be redirected to themselves.
               (On Ultrix, it is not   supported on NFS filesystems.)
               * Usually much faster   than other versions of cat, the/
               */         /* Was the   last line empty?
               */ static char *line_   num_print = line_buf + LINE_/
               */ static char *line_   num_start = line_buf + LINE_/
               /may grow by a factor   of 4 (by the prepending of M-^).
               By default, switching   console        to binary mode/
               Irix-5 returns ENOSYS   on pipes.
               read by the last read   call.       //* Number of characters
               written by each write   call.       //* Number of characters
              (i.e. have two or more   consecutive newlines been read?)
              */        /* The loops   below continue until a newline/
              */   int insize;    /*   Pointer to the input buffer.
              /(ignored)\n\   -v, --   show-nonprinting   use ^ and M-/
              /* Update the pointers   and insert a sentinel at the/     /}
              /newlines, the counter   could wrap     around at INT_MAX.
              A newline character is   always put at the end of the/
              bytes to the beginning   of the    buffer.     /the remaining
              files and print on the   standard output.     /-- concatenate
              number nonblank output   lines\n\   -e/    /--number-nonblank
              on which input file is   open.       /*infile;  /* Descriptor
              See the    GNU General   Public License for more details.
             */        if (tty_in &&   optind <= argc)   setmode (STDOUT_/
             */   char *inbuf;    /*   Pointer to the output buffer.
             */   int outsize;    /*   Optimal size of i/o operations of/
             */  /* Differences from   the Unix cat:    * Always/
             */  static void simple_   cat (      /* Pointer to the/
             ,   scan for chars that   need conversion.    /or -t specified
             /" #endif       , long_   options, NULL)) != -1)     {/
             /* It was a real (not a   sentinel) newline.      /else      {
             /* Read more input into   INBUF.                /= outbuf;   }
             /buffer empties or when   a newline appears in the input.
             /is especially apparent   when using the -v option.
             /it and/or modify    it   under the terms of the GNU General/
             /new input is read, but   before processing of the input/
             /that are set according   to the specified options.
             /use ^ and M- notation,   except for LFD and TAB\n\ "),/
             HP-UX returns ENOTTY on   pipes.           /EOPNOTSUPP on NFS;
             If all       characters   do, and no newlines appear in this/
             If not, we are about to   wait,    so write all buffered/
             Input   files cannot be   redirected to themselves.
             of the first digit in `   line_buf'.    /LEN - 8;  /* Position
             Otherwise, with lots of   consecutive newlines, the counter/
             to binary mode disables   SIGINT.           /switching console
            */         *bpout++ = '\   n';      }    ch = *bpin++;  }/
            */        /* If quoting,   i.e. at least one of -v, -e, or -t/
            , the counter could wrap   around at INT_MAX.         /newlines
            /* Is there any input to   read immediately?    /n_to_read = 0;
            /= 1; #else   int check_   redirection = 0; #endif    /*/
            /from the Unix cat:    *   Always unbuffered, -u is ignored.
            /Granlund and Richard M.   Stallman")  /* Undefine, to avoid/
            /if (full_write (STDOUT_   FILENO, buf, n_read) != n_read)/
            /if (infile[0] == '-' &&   infile[1] == 0)  {    have_read_/
            /is found,   which means   that the buffer is empty or that a/
            /read or written by each   read and write         call.
            /so that BPIN > EOB, and   thereby input      is read/
            /to -vT\n\   -T, --show-   tabs          display TAB/
            >= 2)       {         /*   Limit this to 2 here.     /(newlines
            2 = 0;  /* Count of non-   fatal error conditions.    /newlines
            and insert a sentinel at   the buffer    end.     /the pointers
            check_redirection = 0; #   ifdef lint  /* Suppress `used/    /{
            console        to binary   mode disables SIGINT.     /switching
            Copies the file behind `   input_desc' to STDOUT_FILENO.
            could wrap     around at   INT_MAX.      /newlines, the counter
            display $ at end of each   line\n\   -n, --number/   /show-ends
            else if (ch != '\n')   *   bpout++ = ch;        else   {/    /}
            else if (ch == '\n')   {   newlines = -1;     break;   }/   /';
            if (fstat (input_desc, &   stat_buf) < 0)  {    error (0,/   /}
            If the last character in   the preceding block of input was a/
            Irix-5 returns ENOSYS on   pipes.
            name of this program (e.   g., no `g' prefix).    /The official
            newlines there have been   in the      input.      /consecutive
            number all output lines\   n\   -s, --squeeze-blank/   /-number
            printf (_("\ Usage: %s [   OPTION] [FILE]...\n\ "),/         /{
            SunOS returns EINVAL and   More/BSD returns ENODEV on special/
            This is so "cat > xyzzy"   creates a DOS-style text    file,/
            to the next character in   the input buffer.        //* Pointer
            where the next character   shall be written.      /the position
            You should have received   a copy of the GNU General Public/
           (Besides, if they ask for   one of these options, they don't/
           ); }  /* Compute the next   line number.         /: EXIT_FAILURE
           */         if (mark_line_   ends)   *bpout++ = '$';         /*/
           */     outbuf = xmalloc (   outsize - 1 + insize * 4 + LINE_/
           */   char *outbuf;    int   c;    /* Index in argv to/
           */   dev_t out_dev;    /*   I-node number of the output.
           */   ino_t out_ino;    /*   Nonzero if the output file should/
           */ #define PROGRAM_NAME "   cat"  #define AUTHORS N_ ("/
           */ static char *line_num_   end = line_buf + LINE_COUNTER_BUF_/
           */ static char *line_num_   print = line_buf + LINE_COUNTER_/
           */ static char *line_num_   start = line_buf + LINE_COUNTER_/
           , neither of -v, -e, or -   t specified.    /{    /* Not quoting
           , use the FIONREAD ioctl,   as an optimization.    /* If nonzero
           /- 1 + INSIZE * 4 + LINE_   COUNTER_BUF_LEN)       bytes/
           /- 1 + insize * 4 + LINE_   COUNTER_BUF_LEN);     cat (inbuf,/
           /(insize + 1);     /* Why   are (OUTSIZE - 1 + INSIZE * 4 +/
           /(STDOUT_FILENO, O_TEXT);   else   {     SET_BINARY (input_/
           /* Are line numbers to be   written at empty lines (-n)?      /}
           /* Here CH cannot contain   a newline character.    /_print);  }
           /* If stdin is a terminal   device, and it is the ONLY/      /);
           /* Pointer to the buffer,   used by reads and writes.    /_cat (
           /* Switch stdin to BINARY   mode if needed.    /0;  #if O_BINARY
           /, to avoid warning about   redefinition on some systems.
           /.h" #include "error.h" #   include "full-write.h" #include "/
           /; either version 2, or (   at your option)    any later/
           /along with this program;   if not, write to the Free Software/
           /buffer empties or when a   newline appears in the input.
           /fputs (_("\ \n\   -B, --   binary             use binary/
           /in the hope that it will   be useful,    but WITHOUT ANY/
           /is always put at the end   of the buffer, to make    an/
           /of    MERCHANTABILITY or   FITNESS FOR A PARTICULAR PURPOSE.
           /Stallman. */  #include <   config.h>  #include <stdio.h> #/
           /stdin to binary switches   the console device to   raw I/O,/
           /with)   stdout, and skip   this input file if they coincide.
           __djgpp_set_ctrl_c (1); #   endif   }      } #endif  }/    /_in)
           `used before initialized'   warning.    /ifdef lint  /* Suppress
           a DOS-style text    file,   like people expect.       /" creates
           apparent when using the -   v option.             /is especially
           By tege@sics.se, Torbjorn   Granlund, advised by rms, Richard/
           bytes to the beginning of   the    buffer.        /the remaining
           Called if any option more   than -u was specified.
           empties or when a newline   appears in the input.        /buffer
           if any option more than -   u was specified.              Called
           is empty or that a proper   newline   has been found.    /buffer
           Now INSIZE bytes of input   is read.
           of characters read by the   last read call.      /;    /* Number
           or when a newline appears   in the input.        /buffer empties
           requires seldom more than   LINE_COUNTER_BUF_LEN/   /line number
           size of i/o operations of   input.       /outsize;    /* Optimal
           size of i/o operations of   output.      /**argv) {   /* Optimal
           that are set according to   the specified options.    /Variables
           to the console device.\n\   n\ "), stdout); #endif/      /writes
          (ignored)\n\   -v, --show-   nonprinting   use ^ and M-/       /u
          * Usually much faster than   other versions of cat, the/
          */         /* Was the last   line empty?
          */        if (full_write (   STDOUT_FILENO, buf, n_read) != n_/
          */        if (n_read == 0)   break;        /* Write this block/
          */   if ((!isatty (STDOUT_   FILENO)        && !(numbers ||/
          */   ssize_t n_read;    /*   Determines how many consecutive/
          */   ssize_t n_read;    /*   Loop until the end of the file.
          */  static void next_line_   num (void) {   char *endp = line_/
          */ #undef max #define max(   h,i) ((h) > (i) ? (h) : (i))  /*/
          */ char *program_name;  /*   Name of input file.
          *bpout++ = '^';          *   bpout++ = '?';        }    }/     /{
          , and optimal blocksize of   output.       /device, i-node number
          , and skip this input file   if they coincide.    /with)   stdout
          , file_open_mode);    if (   input_desc < 0)      {/     /(infile
          , neither of -v, -e, or -t   specified.      /{    /* Not quoting
          /")  /* Undefine, to avoid   warning about redefinition on some/
          /"full-write.h" #include "   safe-read.h"   /* The official/
          /# ifdef ENOSYS         ||   errno == ENOSYS # endif         )/
          /# include <sys/ioctl.h> #   endif  #include "system.h" #/
          /(C) 88, 90, 91, 1995-2002   Free Software Foundation, Inc.
          /(STDOUT_FILENO);       /*   When stdout is in binary mode,/
          /)       use_fionread = 0;   else       {         error (0,/
          /)  {    next_line_num ();   bpout = stpcpy (bpout, line_num_/
          /) {   /* Actual number of   characters read, and therefore/
          /);       fputs (_("\   -t   equivalent to -vT\n\   -T, --show-/
          /* Setting stdin to binary   switches the console device to/   /;
          /* Switch stdout to BINARY   mode.                 /_files)     {
          /,       /* Variables that   have values according to the/
          /, except for LFD and TAB\   n\ "), stdout);       fputs (HELP_/
          /, let's show them   those   CR characters as well, so make the/
          /, numbers_at_empty_lines,   mark_line_ends,         squeeze_/
          /, S_IFIFO      on others,   so the checking should not be done/
          //* Compare the device and   i-node numbers of this input file/
          //* The inbuf pointers are   initialized so that BPIN > EOB,/
          /; you can redistribute it   and/or modify    it under the/
          /_at_empty_lines,      int   mark_line_ends,      int squeeze_/
          /_empty_lines) {   /* Last   character read from the input/
          /_empty_lines);     free (   outbuf);  }        free (inbuf);/
          /_name);       fputs (_("\   Concatenate FILE(s), or standard/
          /_POSIX_SOURCE # include <   sys/ioctl.h> #endif  #include "/
          /|| squeeze_empty_lines ||   mark_line_ends))       || binary_/
          /}       else  {    input_   desc = open (infile, file_open_/
          /}   }         /* Output a   currency symbol if requested (-e).
          /} #endif  }       else  {   input_desc = open (infile, file_/
          /<getopt.h> #include <sys/   types.h> #ifndef _POSIX_SOURCE #/
          /= "-";   argind = optind;   do     {       if (argind < argc)/
          /= 0; #endif    /* Nonzero   if we have ever read standard/
          /= 1;  }     }   while (++   argind < argc);    if (have_read_/
          /0 to indicate that we are   at the beginning of a      new/
          /a copy of the GNU General   Public License    along with this/
          /both CR and LF on output,   and the output is readable.
          /bpout = outbuf + (bpout -   wp);      }     /* Is INBUF empty?
          /call simple_cat to do the   actual work. */   int options = 0;/
          /char ch;    /* Pointer to   the next character in the input/
          /consecutive newlines, the   counter could wrap     around at/
          /equivalent to -vET\n\   -   b, --number-nonblank    number/
          /even the implied warranty   of    MERCHANTABILITY or FITNESS/
          /Granlund, advised by rms,   Richard Stallman. */  #include </
          /in the preceding block of   input was a       newline, a line/
          /input file (i.e. we didn'   t write anything to the    output/
          /it under the terms of the   GNU General Public License as/
          /line numbering, squeezing   of empty lines or      marking/
          /lines\n\   -s, --squeeze-   blank      never more than one/
          /may be written (according   to the given       options) as the/
          /mode, make sure all input   files are   also read in binary/
          /S_IFSOCK on some systems,   S_IFIFO      on others, so the/
          /SET_BINARY (0);        /*   Setting stdin to binary switches/
          /struct option const long_   options[] =   {     {"number-/
          /the pointers and insert a   sentinel at the buffer    end.
          /to the position where the   next character shall be written.
          /until a newline character   is found,   which means that the/
          /void simple_cat (      /*   Pointer to the buffer, used by/
          ;    /* Optimal size of i/   o operations of input.      /outsize
          ;   }         /* Read more   input into INBUF.    /bpout = outbuf
          ;  }        /* End of this   file?        /_status = 1;    return
          {       /* Read a block of   input.                */    for (;;)
          }    else      {        /*   It was a real (not a sentinel)/   /;
          about redefinition on some   systems.         /, to avoid warning
          according to the specified   options.           /that have values
          all buffered output before   waiting.       /to wait,    so write
          and i-node numbers of this   input file with   the/   /the device
          ANY WARRANTY; without even   the implied warranty of/    /WITHOUT
          apparent when using the -v   option.               /is especially
          are at least OUTSIZE bytes   in OUTBUF.        //* Write if there
          are the same as the output   file.        /any of the input files
          as well, so make the input   binary.         /those CR characters
          best way to copy the files   verbatim.         /since this is the
          blank line\n\ "), stdout);   fputs (_("\   -t/   /than one single
          But keep console output in   text mode, so that LF causes/
          do  {    /* Write if there   are at least OUTSIZE bytes in/    /{
          error (0, errno, _("cannot   do ioctl on `%s'"), infile);/     /{
          files cannot be redirected   to themselves.                 Input
          GNU General Public License   for more details.            See the
          if (ch >= 32)   {     if (   ch < 127)       *bpout++ = ch;/   /{
          if any option more than -u   was specified.                Called
          int bufsize) {   /* Actual   number of characters read, and/   //
          int input_desc;  /* Buffer   for line numbers.          */ static
          MERCHANTABILITY or FITNESS   FOR A PARTICULAR PURPOSE.        /of
          never more than one single   blank line\n\ "), stdout);/   /blank
          number of characters read,   and therefore written.    //* Actual
          number of the output (file   or whatever).        /;    /* Device
          of 4 (by the prepending of   M-^).          /may grow by a factor
          of characters read in each   read call.        /,       /* Number
          output needs to be written   is done when the input/     /whether
          Place - Suite 330, Boston,   MA 02111-1307, USA.    /., 59 Temple
          SET_BINARY (input_desc); #   ifdef __DJGPP__     /* This is/   /{
          unless the number of lines   is larger than 999999.       /change
          warning about redefinition   on some systems.         /, to avoid
          with this program; if not,   write to the Free Software/   /along
          You should have received a   copy of the GNU General Public/
         (close_stdout);    /* Parse   command line options.        /atexit
         );         exit_status = 1;   newlines2 = newlines;/   /"), infile
         );    /* Parse command line   options.       /atexit (close_stdout
         */         memmove (outbuf,   wp, bpout - wp);        bpout =/
         */        /* If quoting, i.   e. at least one of -v, -e, or -t/
         */       binary_output = 1;   SET_BINARY (STDOUT_FILENO);/
         */      char *buf,       /*   Number of characters preferably/
         */      int bufsize) {   /*   Actual number of characters read,/
         */      int quote,      int   output_tabs,      int numbers,/
         */     if (tty_in)       __   djgpp_set_ctrl_c (1); # endif   }/
         */    eob = inbuf;   bpin =   eob + 1;    bpout = outbuf;    for/
         */   int numbers = 0;   int   numbers_at_empty_lines = 1;   int/
         */  /* Differences from the   Unix cat:    * Always unbuffered,/
         */ static char *infile;  /*   Descriptor on which input file is/
         , i.e. the      current end   of the buffer.     /the input buffer
         . (Done after the       new   input is read, but before/   /buffer
         /(_("\ \n\ With no FILE, or   when FILE is -, read standard/
         /(_("\ Concatenate FILE(s),   or standard input, to standard/
         /(_("\ Usage: %s [OPTION] [   FILE]...\n\ "),        program_/
         /(++argind < argc);    if (   have_read_stdin && close (0) < 0)/
         /(input_desc, FIONREAD, &n_   to_read) < 0)   {     /* Ultrix/
         /(insize);     simple_cat (   inbuf, insize);  }       else  {/
         /(STDOUT_FILENO, outbuf, n_   write) != n_write)       error (/
         /))  {    error (0, 0, _("%   s: input file is output file"),/
         /);        exit_status = 1;   continue;      }  }        if (/
         /);       /* When stdout is   in binary mode, make sure all/
         /);   textdomain (PACKAGE);   atexit (close_stdout);    /* Parse/
         /* cat -- concatenate files   and print on the standard output.
         /* Here CH cannot contain a   newline character.      /_print);  }
         /* Output a currency symbol   if requested (-e).    /;       }   }
         /* Pointer to the beginning   of the input buffer.     /void cat (
         /* Pointer to the beginning   of the output buffer.       /insize,
         /, if they ask for      one   of these options, they don't care/
         /, NULL, 'B'}, #endif     {   GETOPT_HELP_OPTION_DECL},     {/
         /, squeezing of empty lines   or      marking lines' ends: then/
         /, wp, outsize) != outsize)   error (EXIT_FAILURE, errno, _("/
         //* Are we at the beginning   of a line, and line numbers are/
         //* If they want to see the   non-printables, let's show them/
         //* Update the pointers and   insert a sentinel at the buffer/
         /;    }       }      /* Are   line numbers to be written at/
         /;    int c;    /* Index in   argv to processed argument.
         /; either version 2, or (at   your option)    any later version.
         /; without even the implied   warranty of    MERCHANTABILITY or/
         /_at_empty_lines = 1;   int   squeeze_empty_lines = 0;   int/
         /_BUF_LEN - 3;  /* Position   of the last digit in `line_buf'.
         /_BUF_LEN - 8;  /* Position   of the first digit in `line_buf'.
         /_BUF_LEN);     cat (inbuf,   insize, outbuf, outsize, quote,/
         /_HELP_CHAR;   case_GETOPT_   VERSION_CHAR (PROGRAM_NAME,/
         /{        if (ch >= 32)   {   if (ch < 127)       *bpout++ = ch;/
         /{       /* If they want to   see the non-printables, let's show/
         /{       if (argind < argc)   infile = argv[argind];        if (/
         /{"show-ends", no_argument,   NULL, 'E'},     {"show-tabs", no_/
         /{"show-tabs", no_argument,   NULL, 'T'},     {"show-all", no_/
         /}      /* Are line numbers   to be written at empty lines (-n)?
         /}    /* Get device, i-node   number, and optimal blocksize of/
         /= 1;    input_desc = 0;  #   if O_BINARY    /* Switch stdin to/
         /= line_buf + LINE_COUNTER_   BUF_LEN - 3;  /* Position of the/
         /= line_buf + LINE_COUNTER_   BUF_LEN - 8;  /* Position of the/
         /= stpcpy (bpout, line_num_   print);       }   }         /*/
         /= stpcpy (bpout, line_num_   print);  }        /* Here CH/
         /== 0)  {    insize = max (   insize, outsize);    inbuf =/
         /are when      they request   line numbering, squeezing of empty/
         /char *buf,       /* Number   of characters preferably read or/
         /character is always put at   the end of the buffer, to make/
         /device to   raw I/O, which   also affects stdout to console.
         /device, and it is the ONLY   input file (i.e. we didn't write/
         /do, and no newlines appear   in this block of input, we/
         /EINVAL and        More/BSD   returns ENODEV on special files/
         /file (i.e. we didn't write   anything to the    output yet),/
         /files either. */    if (S_   ISREG (stat_buf.st_mode))     {/
         /if (numbers && numbers_at_   empty_lines)       {         next_/
         /in BINARY mode, since this   is the      best way to copy the/
         /in this block of input, we   will have at most (OUTSIZE - 1 +/
         /input file (i.e. we didn't   write anything to the    output/
         /insize = ST_BLKSIZE (stat_   buf);        /* Compare the device/
         /is distributed in the hope   that it will be useful,    but/
         /License    along with this   program; if not, write to the Free/
         /More/BSD returns ENODEV on   special files        like /dev//
         /n_read = safe_read (input_   desc, buf, bufsize);       if (n_/
         /newline, a line number may   be written (according to the given/
         /one of these options, they   don't care much about the original/
         /out_dev = stat_buf.st_dev;   out_ino = stat_buf.st_ino;     }/
         /preferably read or written   by each read and write/
         /returns EOPNOTSUPP on NFS;   HP-UX returns ENOTTY on pipes.
         /that have values according   to the specified options.
         /to -vET\n\   -b, --number-   nonblank    number nonblank output/
         /to be written is done when   the input       buffer empties or/
         /users on DOS/Windows where   a line      with only CR-LF is an/
         /values of the (output file   associated with)   stdout, and/
         /void cat (      /* Pointer   to the beginning of the input/
         ;    /* Optimal size of i/o   operations of input.    /int outsize
         _t n_read;    /* Loop until   the end of the file.      */   ssize
         {        /* It was a real (   not a sentinel) newline.       /else
         {       /* Switch stdout to   BINARY mode.       /|| binary_files)
         } }  /* Cat the file behind   INPUT_DESC to the file behind/   /);
         ++ = '$';         /* Output   the newline.    /line_ends)   *bpout
         == 0 ? EXIT_SUCCESS : EXIT_   FAILURE); }       /exit (exit_status
         330, Boston, MA 02111-1307,   USA.           /Temple Place - Suite
         a line      with only CR-LF   is an empty line.    //Windows where
         a proper newline   has been   found.             /is empty or that
         A test whether output needs   to be written is done when the/
         an explicit test for buffer   end unnecessary.    /buffer, to make
         and        More/BSD returns   ENODEV on special files/     /EINVAL
         break;   case 'u':    /* We   provide the -u feature/        /= 1;
         can be output file for non-   regular files.    /;   /* Input file
         CH cannot contain a newline   character.     /);  }        /* Here
         do     {       if (argind <   argc)  infile = argv[argind];/    /;
         do   {     if (full_write (   STDOUT_FILENO, wp, outsize) !=/   /;
         file can be output file for   non-regular files.    /);   /* Input
         if (!STREQ (infile, "-") &&   close (input_desc) < 0)  {/       /:
         If all       characters do,   and no newlines appear in this/
         input, to standard output.\   n\ \n\   -A, --show-all/   /standard
         int numbers_at_empty_lines,   int mark_line_ends,      int/     /,
         is especially apparent when   using the -v option.     /difference
         M. Stallman")  /* Undefine,   to avoid warning about/     /Richard
         more than LINE_COUNTER_BUF_   LEN       positions.         /seldom
         name of this program (e.g.,   no `g' prefix).     //* The official
         newlines there have been in   the      input.    /many consecutive
         number requires seldom more   than LINE_COUNTER_BUF_LEN/    A line
         of a line, and line numbers   are requested?     /at the beginning
         of the last digit in `line_   buf'.        /_LEN - 3;  /* Position
         of this program (e.g., no `   g' prefix).    //* The official name
         or FITNESS FOR A PARTICULAR   PURPOSE.      /of    MERCHANTABILITY
         or written by each read and   write         call.            /read
         outsize = ST_BLKSIZE (stat_   buf);   /* Input file can be/   /));
         raw I/O, which also affects   stdout to console.        /device to
         return;  }        /* End of   this file?         /exit_status = 1;
         simple_cat to do the actual   work. */   int options = 0;/   /call
         terminal        reads to be   interruptible.           But we want
         the next character shall be   written.      /to the position where
         This program is distributed   in the hope that it will be useful/
         where a line      with only   CR-LF is an empty line.    //Windows
         with only CR-LF is an empty   line.                  /where a line
        (;;)     {       do  {    /*   Write if there are at least/    /for
        )       error (EXIT_FAILURE,   errno, _("write error"));/   /_write
        ) {   /* Last character read   from the input buffer.       /_lines
        ) {   /* Optimal size of i/o   operations of output.        /**argv
        */        /* The loops below   continue until a newline character/
        */       if (isatty (STDOUT_   FILENO))  setmode (STDOUT_FILENO,/
        */      int insize,       /*   Pointer to the beginning of the/
        */     if (bpout - outbuf >=   outsize)      {        char *wp =/
        */   dev_t out_dev;    /* I-   node number of the output.
        */   int use_fionread = 1; #   endif    /* The inbuf pointers are/
        */   unsigned char ch;    /*   Pointer to the next character in/
        */ #undef max #define max(h,   i) ((h) > (i) ? (h) : (i))  /*/
        *inbuf;    /* Pointer to the   output buffer.             */   char
        *line_buf = '>';   if (line_   num_start < line_num_print)/   /else
        ,   scan for chars that need   conversion.     /-e, or -t specified
        , argv, #if O_BINARY       "   benstuvABET" #else       "/   /(argc
        , i-node number, and optimal   blocksize of output.     /Get device
        , it is not supported on NFS   filesystems.)             (On Ultrix
        , numbers, numbers_at_empty_   lines, mark_line_ends,/       /_tabs
        , use the FIONREAD ioctl, as   an optimization.      //* If nonzero
        /' ends: then we use text I/   O, because otherwise      -b, -s/
        /'E':    ++options;    mark_   line_ends = 1;    break;   case 'T/
        /'e':    ++options;    mark_   line_ends = 1;    quote = 1;/
        /- outbuf >= outsize)      {   char *wp = outbuf;        do   {/
        /-blank      never more than   one single blank line\n\ "),/
        /"));     wp += outsize;   }   while (bpout - wp >= outsize);/
        /"benstuvABET" #else       "   benstuvAET" #endif       , long_/
        /"benstuvAET" #endif       ,   long_options, NULL)) != -1)     {/
        /(_("\nReport bugs to <%s>.\   n"), PACKAGE_BUGREPORT);     }/
        /(0, 0, _("%s: input file is   output file"), infile);    exit_/
        /(ch == '\n');        /* Are   we at the beginning of a line, and/
        /(EXIT_FAILURE, errno, "-");   exit (exit_status == 0 ? EXIT_/
        /(input_desc);         /* If   stdin is a terminal device, and it/
        /(input_desc, buf, bufsize);   if (n_read < 0)  {    error (0,/
        /(more than -u,   --version,   or --help) were specified, use `/
        /(outsize - 1 + insize * 4 +   LINE_COUNTER_BUF_LEN);     cat (/
        /(stat_buf);   /* Input file   can be output file for non-regular/
        /(stderr, _("Try `%s --help'   for more information.\n"),/
        /(STDOUT_FILENO))  setmode (   STDOUT_FILENO, O_TEXT);     } #/
        /) != n_write)       error (   EXIT_FAILURE, errno, _("write/
        /) != outsize)       error (   EXIT_FAILURE, errno, _("write/
        /) as the first thing in the   output buffer. (Done after the/
        /))  setmode (STDOUT_FILENO,   O_TEXT);     } #endif    /* Check/
        /);       if (n_read < 0)  {   error (0, errno, "%s", infile);/
        /);      contin:       if (!   STREQ (infile, "-") && close (/
        /* 4 + LINE_COUNTER_BUF_LEN)   bytes allocated for the output/
        /* Loop until the end of the   file.               /ssize_t n_read;
        /* Not quoting, neither of -   v, -e, or -t specified.     /else  {
        /* Number of characters read   by the last read call.      /*bpout;
        /* Number of characters read   in each read call.     /char *inbuf,
        /* The official name of this   program (e.g., no `g' prefix).    /"
        /* Ultrix returns EOPNOTSUPP   on NFS;        HP-UX returns/     /{
        /* We provide the -u feature   unconditionally.      /;   case 'u':
        /**argv) {   /* Optimal size   of i/o operations of output.
        /*bpin;    /* Pointer to the   first non-valid byte in the input/
        /*outbuf,       /* Number of   characters written by each write/
        /*wp = outbuf;        do   {   if (full_write (STDOUT_FILENO, wp,/
        /, errno, _("write error"));   bpout = outbuf;   }         /*/
        /, errno, _("write error"));   wp += outsize;   }        while (/
        /, insize);  }       else  {   inbuf = xmalloc (insize + 1);/
        /.\n"),       program_name);   else     {       printf (_("\/
        /.h" #include "closeout.h" #   include "error.h" #include "full-/
        /.h> #ifndef _POSIX_SOURCE #   include <sys/ioctl.h> #endif  #/
        //* Move the remaining bytes   to the beginning of the    buffer.
        //* The loops below continue   until a newline character is found/
        //* We always read and write   in BINARY mode, since this is the/
        //* When stdout is in binary   mode, make sure all input files/
        /;       }   }        if (n_   to_read == 0) #endif   {     size_/
        /;    numbers = 1;    break;   case 's':    ++options;    squeeze/
        /;   }         /* Update the   pointers and insert a sentinel at/
        /;   }        else   {     *   bpout++ = '^';     *bpout++ = ch +/
        /;   }        while (bpout -   wp >= outsize);         /* Move/
        /;   case 'A':    ++options;   quote = 1;    mark_line_ends = 1;/
        /;   case 'b':    ++options;   numbers = 1;    numbers_at_empty_/
        /;   case 'e':    ++options;   mark_line_ends = 1;    quote = 1;/
        /;   case 'n':    ++options;   numbers = 1;    break;   case 's':/
        /;   case 's':    ++options;   squeeze_empty_lines = 1;    break;/
        /;   case 'T':    ++options;   output_tabs = 0;    break;   case_/
        /;   case 't':    ++options;   output_tabs = 0;    quote = 1;/
        /;   case 'v':    ++options;   quote = 1;    break;   case 'A':/
        /;  /* If nonzero, call cat,   otherwise call simple_cat to do/
        /;  }        /* Select which   version of `cat' to use. If any/
        /; if not, write to the Free   Software Foundation,    Inc., 59/
        /_at_empty_lines, mark_line_   ends,         squeeze_empty_lines)/
        /_BUF_LEN - 3;  /* Preserves   the `cat' function's local `/
        /_BUGREPORT);     }   exit (   status == 0 ? EXIT_SUCCESS : EXIT_/
        /_desc = open (infile, file_   open_mode);    if (input_desc < 0)/
        /_desc) < 0)  {    error (0,   errno, "%s", infile);    exit_/
        /_desc);         /* If stdin   is a terminal device, and it is/
        /_empty_lines = 1;    break;   case 't':    ++options;    output_/
        /_FILENO))  setmode (STDOUT_   FILENO, O_TEXT);     } #endif    //
        /_FILENO, buf, n_read) != n_   read)  error (EXIT_FAILURE, errno,/
        /_lines,      int mark_line_   ends,      int squeeze_empty_lines/
        /_NAME, AUTHORS);   default:   usage (EXIT_FAILURE);  }     }/
        /_t n_read;    /* Determines   how many consecutive newlines/
        /_tabs, numbers, numbers_at_   empty_lines, mark_line_ends,/
        /{         next_line_num ();   bpout = stpcpy (bpout, line_num_/
        /{        char *wp = outbuf;   do   {     if (full_write (STDOUT_/
        /{       out_dev = stat_buf.   st_dev;       out_ino = stat_buf./
        /{     *bpout++ = '^';     *   bpout++ = ch + 64;   }         ch/
        /}   else     {       check_   redirection = 0; #ifdef lint  /*/
        /}  }     } }  int main (int   argc, char **argv) {   /* Optimal/
        /} #endif    /* Check if any   of the input files are the same as/
        /++ = '\n';      }    ch = *   bpin++;  }       while (ch == '\n'/
        /++ = '\t';        else if (   ch == '\n')   {     newlines = -1;/
        /< line_num_print)     line_   num_print--; }  /* Plain cat.
        /<= argc)   setmode (STDOUT_   FILENO, O_TEXT);        else   {/
        /<stdio.h> #include <getopt.   h> #include <sys/types.h> #ifndef/
        /= 0;   int quote = 0;   int   output_tabs = 1; #if O_BINARY/
        /= 1;    mark_line_ends = 1;   output_tabs = 0;    break;  #if O_/
        /= 1; #endif    /* The inbuf   pointers are initialized so that/
        /= argv[0];   setlocale (LC_   ALL, "");   bindtextdomain (/
        /= argv[argind];        if (   infile[0] == '-' && infile[1] == 0/
        /= bpout - outbuf;      if (   full_write (STDOUT_FILENO, outbuf,/
        /= O_RDONLY;  /* If nonzero,   call cat, otherwise call simple_/
        /= outbuf;    for (;;)     {   do  {    /* Write if there are at/
        /== 0 ? EXIT_SUCCESS : EXIT_   FAILURE); }  /* Compute the next/
        /== 0) #endif   {     size_t   n_write = bpout - outbuf;      if/
        /== ENOSYS # endif         )   use_fionread = 0;     else       {/
        /2;  #ifdef FIONREAD   /* If   nonzero, use the FIONREAD ioctl,/
        /along with this program; if   not, write to the Free Software/
        /as published by    the Free   Software Foundation; either/
        /bugs to <%s>.\n"), PACKAGE_   BUGREPORT);     }   exit (status =/
        /cat (inbuf, insize, outbuf,   outsize, quote,         output_/
        /cat, otherwise call simple_   cat to do the actual work. *//
        /char line_buf[LINE_COUNTER_   BUF_LEN] =   {     ' ', ' ', ' ',/
        /character       may grow by   a factor of 4 (by the prepending/
        /character is found,   which   means that the buffer is empty or/
        /contin;  }        /* Select   which version of `cat' to use. If/
        /counter may overflow within   an hour on a P2/466,    an 18/
        /device.\n\n\ "), stdout); #   endif       printf (_("\nReport/
        /display TAB characters as ^   I\n\   -u                       (/
        /either. */    if (S_ISREG (   stat_buf.st_mode))     {       out/
        /else   {     newlines = -1;   break;   }         ch = *bpin++;/
        /file should not be the same   as any input file. */ #ifndef _WIN/
        /FILE(s), or standard input,   to standard output.\n\ \n\   -A, -/
        /file_open_mode |= O_BINARY;   SET_BINARY (0);        /* Setting/
        /for (;;)      {        if (   ch == '\t' && !output_tabs)   {/
        /for (;;)      {        if (   ch >= 32)   {     if (ch < 127)/
        /for device files either. */   if (S_ISREG (stat_buf.st_mode))/
        /have at most (OUTSIZE - 1 +   INSIZE * 4) bytes in the buffer.
        /have received a copy of the   GNU General Public License/
        /if (check_redirection    &&   stat_buf.st_dev == out_dev && stat/
        /if (fstat (STDOUT_FILENO, &   stat_buf) < 0)     error (EXIT_/
        /if (isatty (STDOUT_FILENO))   setmode (STDOUT_FILENO, O_TEXT);/
        /in the hope that it will be   useful,    but WITHOUT ANY/
        /in the output buffer. (Done   after the       new input is read,/
        /int quote,      int output_   tabs,      int numbers,      int/
        /int tty_in = isatty (input_   desc);         /* If stdin is a/
        /is -, read standard input.\   n\ "), stdout); #if O_BINARY/
        /is always put at the end of   the buffer, to make    an explicit/
        /is so "cat > xyzzy" creates   a DOS-style text    file, like/
        /like cat < /dev/tty > /dev/   tty, checking      is not done for/
        /long_options[] =   {     {"   number-nonblank", no_argument,/
        /may grow by a factor of 4 (   by the prepending of M-^).
        /may overflow within an hour   on a P2/466,    an 18 digit/
        /needs to be written is done   when the input       buffer/
        /newlines, the counter could   wrap     around at INT_MAX.
        /no FILE, or when FILE is -,   read standard input.\n\ "), stdout/
        /non-valid byte in the input   buffer, i.e. the      current end/
        /numbers = 1;    numbers_at_   empty_lines = 0;    break;   case/
        /numbers_at_empty_lines = 0;   break;   case 'e':    ++options;/
        /on a P2/466,    an 18 digit   counter needs about 1000y */ #/
        /on DOS/Windows where a line   with only CR-LF is an empty line.
        /options) as the first thing   in the output buffer. (Done after/
        /otherwise      -b, -s and -   E would surprise users on DOS//
        /output"));    outsize = ST_   BLKSIZE (stat_buf);   /* Input/
        /pointers are initialized so   that BPIN > EOB, and thereby input/
        /PROGRAM_NAME "cat"  #define   AUTHORS N_ ("Torbjorn Granlund and/
        /program_name);   else     {   printf (_("\ Usage: %s [OPTION] [/
        /Public License as published   by    the Free Software Foundation/
        /Software Foundation; either   version 2, or (at your option)/
        /struct stat stat_buf;    /*   Variables that are set according/
        /switches the console device   to   raw I/O, which also affects/
        /TAB characters as ^I\n\   -   u                       (ignored)\/
        /than -u,   --version, or --   help) were specified, use `cat',/
        /than one single blank line\   n\ "), stdout);       fputs (_("\/
        /than other versions of cat,   the difference    is especially/
        /that the buffer is empty or   that a proper newline   has been/
        /the buffer is empty or that   a proper newline   has been found.
        /the console device to   raw   I/O, which also affects stdout to/
        /the corresponding values of   the (output file associated with)/
        /this program; if not, write   to the Free Software Foundation,/
        /to -vE\n\   -E, --show-ends   display $ at end of each line\n\/
        /to -vT\n\   -T, --show-tabs   display TAB characters as ^I\n\/
        /to the first non-valid byte   in the input buffer, i.e. the/
        /to the given       options)   as the first thing in the output/
        /usage (int status) {   if (   status != 0)     fprintf (stderr,/
        /version of `cat' to use. If   any options (more than -u,   --/
        /void next_line_num (void) {   char *endp = line_num_end;   do/
        /was a       newline, a line   number may be written (according/
        /when the input       buffer   empties or when a newline appears/
        /within an hour on a P2/466,   an 18 digit counter needs about 10/
        /work. */   int options = 0;   static struct option const long_/
        ;        /* Write this block   out.           /(n_read == 0)  break
        ;    /* Pointer to the input   buffer.              */   int insize
        _FAILURE); }  /* Compute the   next line number.    /SUCCESS : EXIT
        _num ();    bpout = stpcpy (   bpout, line_num_print);  }/   /_line
        _status = 1;     newlines2 =   newlines;     return;   }/     /exit
        {         /* Limit this to 2   here.                /newlines >= 2)
        {     error (0, errno, "%s",   infile);     exit_status = 1;/   /0)
        {    /* Not quoting, neither   of -v, -e, or -t specified.    /else
        }         /* Read more input   into INBUF.         /bpout = outbuf;
        }   while (endp >= line_num_   start);   if (line_num_start >/   /;
        = 0;         /* Is there any   input to read immediately?    /_read
        = 1;    return;  }        /*   End of this file?       /exit_status
        about the original      file   contents anyway).      /'t care much
        and insert a sentinel at the   buffer    end.         /the pointers
        at the end of the buffer, to   make    an explicit test for/   /put
        atexit (close_stdout);    /*   Parse command line options.      /);
        console device to   raw I/O,   which also affects stdout to/   /the
        CR and LF on output, and the   output is readable.            /both
        device and i-node numbers of   this input file with   the/     /the
        ditto (-s), and this was the   second empty     line?    /by single
        else  {    inbuf = xmalloc (   insize + 1);     /* Why are (/    /}
        for (;;)     {       /* Read   a block of input.                 */
        have values according to the   specified options.             /that
        if (ch < 128 + 127)        *   bpout++ = ch - 128;      else/    /{
        if (quote)     {       /* If   they want to see the non-/     /else
        If the last character in the   preceding block of input was a/
        in `line_buf' where printing   starts.        /0'   };  /* Position
        Initially 0 to indicate that   we are at the beginning of a/
        insize;    /* Pointer to the   input buffer.               */   int
        int insize,       /* Pointer   to the beginning of the output/   //
        int insize;    /* Pointer to   the input buffer.                 */
        int quote = 0;   int output_   tabs = 1; #if O_BINARY   int/    /0;
        int squeeze_empty_lines = 0;   int mark_line_ends = 0;   int/   /1;
        is the      best way to copy   the files verbatim.    /, since this
        LF on output, and the output   is readable.            /both CR and
        loops below continue until a   newline character is found,/    /The
        memmove (outbuf, wp, bpout -   wp);        bpout = outbuf + (/   //
        n_to_read = 0;         /* Is   there any input to read/        /int
        NEWLINES -1, 1 newline makes   NEWLINES 1,      etc.         /makes
        Now INSIZE bytes of input is   read.
        of the buffer, to make    an   explicit test for buffer end/   /end
        of the first digit in `line_   buf'.         /LEN - 8;  /* Position
        of these options, they don't   care much about the original/   /one
        on NFS;        HP-UX returns   ENOTTY on pipes.         /EOPNOTSUPP
        or more consecutive newlines   been read?)           (i.e. have two
        or when a newline appears in   the input.           /buffer empties
        same as any input file. */ #   ifndef _WIN32     int check_/   /the
        skip this input file if they   coincide.       /with)   stdout, and
        so write all buffered output   before waiting.      /about to wait,
        that we are at the beginning   of a      new line.     /to indicate
        The "state" of the procedure   is determined by      NEWLINES.
        the file behind `input_desc'   to STDOUT_FILENO.             Copies
        they request line numbering,   squeezing of empty lines or/   /when
        this is the      best way to   copy the files verbatim.    /, since
        those CR characters as well,   so make the input binary.      /them
        to allow things like cat < /   dev/tty > /dev/tty, checking/   /and
        to the buffer, used by reads   and writes.       /(      /* Pointer
        to the next character in the   input buffer.     /ch;    /* Pointer
        under which this program was   invoked.        /(h) : (i))  /* Name
        we are at the beginning of a   new line.             /indicate that
        yet), switch the output back   to TEXT mode.      /to the    output
       #if O_BINARY  case 'B':    ++   options;    binary_files = 1;/    /;
       (-s), and this was the second   empty     line?     /by single ditto
       (at your option)    any later   version.              /version 2, or
       (ch != '\n')   *bpout++ = ch;   else   {     newlines = -1;/     /if
       (newlines >= 0 && numbers)  {   next_line_num ();    bpout =/    /if
       )     line_num_print--; }  /*   Plain cat.         /< line_num_print
       */         if (squeeze_empty_   lines)    {      ch = *bpin++;/
       */        /* If quoting, i.e.   at least one of -v, -e, or -t/
       */       file_open_mode |= O_   BINARY;       SET_BINARY (0);/
       */       file_open_mode |= O_   BINARY;     }   else if (quote)/
       */      char *inbuf,       /*   Number of characters read in each/
       */      int outsize,       /*   Variables that have values/
       */    for (;;)     {       /*   Read a block of input.
       */   char *eob;    /* Pointer   to the position where the next/
       */   int argind;    /* Device   number of the output (file or/
       */  static void cat (      /*   Pointer to the beginning of the/
       */ static int input_desc;  /*   Buffer for line numbers.
       *bpout++ = '?';        }    }   else    {      *bpout++ = '^';/   /;
       , and skip this input file if   they coincide.       /with)   stdout
       /- wp >= outsize);         /*   Move the remaining bytes to the/
       /-b, -s and -E would surprise   users on DOS/Windows where a line/
       /-ends", no_argument, NULL, '   E'},     {"show-tabs", no_argument/
       /-tabs", no_argument, NULL, '   T'},     {"show-all", no_argument,/
       /" #else       "benstuvAET" #   endif       , long_options, NULL))/
       /"cat"  #define AUTHORS N_ ("   Torbjorn Granlund and Richard M./
       /# endif         )       use_   fionread = 0;     else       {/
       /$ at end of each line\n\   -   n, --number             number all/
       /();         bpout = stpcpy (   bpout, line_num_print);       }/
       /(0);        /* Setting stdin   to binary switches the console/
       /(input_desc, inbuf, insize);   if (n_read < 0)   {     error (0,/
       /(PACKAGE);    atexit (close_   stdout);    /* Parse command line/
       /(STDOUT_FILENO)        && !(   numbers || squeeze_empty_lines ||/
       /(VERSION_OPTION_DESCRIPTION,   stdout);       fputs (_("\ \n\/
       /)       {         next_line_   num ();         bpout = stpcpy (/
       /)       error (EXIT_FAILURE,   errno, _("write error"));     wp +/
       /)      {        int tty_in =   isatty (input_desc);         /* If/
       /) {   char *endp = line_num_   end;   do     {       if ((*endp)+/
       /) were specified, use `cat',   otherwise use   `simple_cat'.
       /))  {    error (0, 0, _("%s:   input file is output file"),/
       /);       fputs (HELP_OPTION_   DESCRIPTION, stdout);       fputs/
       /);    if (have_read_stdin &&   close (0) < 0)     error (EXIT_/
       /); #endif       printf (_("\   nReport bugs to <%s>.\n"), PACKAGE/
       /* 4 + LINE_COUNTER_BUF_LEN);   cat (inbuf, insize, outbuf,/
       /* Are we at the beginning of   a line, and line numbers are/   /');
       /* Index in argv to processed   argument.               /;    int c;
       /* Is there any input to read   immediately?             /_read = 0;
       /* Nonzero if the output file   should not be the same as any/    /;
       /* Position of the last digit   in `line_buf'.        /_BUF_LEN - 3;
       /*bpout++ = '-';         if (   ch >= 128 + 32)    {      if (ch </
       /*bpout++ = '\t';        else   if (ch == '\n')   {     newlines =/
       /*bpout++ = ch;     else if (   ch == 127)       {         *bpout+/
       /*line_num_print = line_buf +   LINE_COUNTER_BUF_LEN - 8;  /*/
       /*line_num_start = line_buf +   LINE_COUNTER_BUF_LEN - 3;  /*/
       /, 'T'},     {"show-all", no_   argument, NULL, 'A'}, #if O_BINARY/
       /,      int numbers,      int   numbers_at_empty_lines,      int/
       /,      int numbers_at_empty_   lines,      int mark_line_ends,/
       /,    Inc., 59 Temple Place -   Suite 330, Boston, MA 02111-1307,/
       /, i.e. at least one of -v, -   e, or -t specified,   scan for/
       /, let's show them   those CR   characters as well, so make the/
       /, LOCALEDIR);   textdomain (   PACKAGE);    atexit (close_stdout)/
       /, NULL, 'b'},     {"number",   no_argument, NULL, 'n'},     {"/
       /, NULL, 'n'},     {"squeeze-   blank", no_argument, NULL, 's'},/
       /, or --help) were specified,   use `cat', otherwise use   `simple/
       /, S_IFIFO      on others, so   the checking should not be done/
       /, so the checking should not   be done for those types,      and/
       /, they don't care much about   the original      file contents/
       /. */  #include <config.h>  #   include <stdio.h> #include <getopt/
       /.h> #include <sys/types.h> #   ifndef _POSIX_SOURCE # include </
       //* Check if any of the input   files are the same as the output/
       //* Compare the device and i-   node numbers of this input file/
       //* If quoting, i.e. at least   one of -v, -e, or -t specified,/
       //* Pointer to the first non-   valid byte in the input buffer, i./
       //* Select which version of `   cat' to use. If any options (more/
       /;        *eob = '\n';      }   else      {        /* It was a/
       /;       *endp-- = '0';     }   while (endp >= line_num_start);/
       /;     return;   }         /*   Update the pointers and insert a/
       /;    /* Device number of the   output (file or whatever).
       /;    /* Number of characters   read by the last read call.
       /;    /* Pointer to the first   non-valid byte in the input buffer/
       /@sics.se, Torbjorn Granlund,   advised by rms, Richard Stallman./
       /_buf);        /* Compare the   device and i-node numbers of this/
       /_buf.st_dev;       out_ino =   stat_buf.st_ino;     }   else/
       /_c (1); # endif   }      } #   endif  }       else  {    input_/
       /_COUNTER_BUF_LEN);     cat (   inbuf, insize, outbuf, outsize,/
       /_DECL},     {GETOPT_VERSION_   OPTION_DECL},     {NULL, 0, NULL,/
       /_FAILURE, errno, _("standard   output"));    outsize = ST_BLKSIZE/
       /_FILENO, outbuf, n_write) !=   n_write)       error (EXIT_FAILURE/
       /_files = 1;    break; #endif   case 'E':    ++options;    mark_/
       /_line_ends,         squeeze_   empty_lines);     free (outbuf);/
       /_lines = 0;   int mark_line_   ends = 0;   int quote = 0;   int/
       /_NAME "cat"  #define AUTHORS   N_ ("Torbjorn Granlund and Richard/
       /_num (void) {   char *endp =   line_num_end;   do     {       if/
       /_num_start < line_num_print)   line_num_print--; }  /* Plain cat.
       /_num_start);   if (line_num_   start > line_buf)     *--line_num_/
       /_OPTION_DECL},     {NULL, 0,   NULL, 0}   };    program_name =/
       /_redirection    && stat_buf.   st_dev == out_dev && stat_buf.st_/
       /_t n_write = bpout - outbuf;   if (full_write (STDOUT_FILENO,/
       /_tabs = 0;    break;   case_   GETOPT_HELP_CHAR;   case_GETOPT_/
       /_tabs = 0;    break;  #if O_   BINARY  case 'B':    ++options;/
       /_VERSION_CHAR (PROGRAM_NAME,   AUTHORS);   default:    usage (/
       /_VERSION_OPTION_DECL},     {   NULL, 0, NULL, 0}   };    program_/
       /{        error (0, errno, "%   s", infile);        exit_status =/
       /{        if (ch == '\t' && !   output_tabs)   {     *bpout++ = '^/
       /{       do  {    /* Write if   there are at least OUTSIZE bytes/
       /{       if ((*endp)++ < '9')   return;       *endp-- = '0';     }/
       /{ #ifdef FIONREAD        int   n_to_read = 0;         /* Is there/
       /|| mark_line_ends))       ||   binary_files)     {       /*/
       /}     else       {         *   bpout++ = 'M';         *bpout++ =/
       /}   while (++argind < argc);   if (have_read_stdin && close (0) </
       /}  }       else  {    /* Not   quoting, neither of -v, -e, or -t/
       /++;  }       while (ch == '\   n');        /* Are we at the/
       /++options;    squeeze_empty_   lines = 1;    break;   case 't':/
       /< 0)      {        error (0,   errno, "%s", infile);        exit_/
       /<config.h>  #include <stdio.   h> #include <getopt.h> #include </
       /= 0;    break;  #if O_BINARY   case 'B':    ++options;    binary_/
       /= 0;    quote = 1;    break;   case 'u':    /* We provide the -u/
       /= 0;    static struct option   const long_options[] =   {     {"/
       /= 0;   int numbers_at_empty_   lines = 1;   int squeeze_empty_/
       /= 0; #endif    /* Nonzero if   we have ever read standard input./
       /= 0; #endif   int file_open_   mode = O_RDONLY;  /* If nonzero,/
       /= 1;    input_desc = 0;  #if   O_BINARY    /* Switch stdin to/
       /= 1;    quote = 1;    break;   case 'n':    ++options;    numbers/
       /= inbuf;        eob = bpin +   n_read;        *eob = '\n';      }/
       /> /dev/tty, checking      is   not done for device files either./
       /> line_buf)     *--line_num_   start = '1';   else     *line_buf/
       /> xyzzy" creates a DOS-style   text    file, like people expect.
       />= 0 && numbers)  {    next_   line_num ();    bpout = stpcpy (/
       /0 to indicate that we are at   the beginning of a      new line.
       /about 1000y */ #define LINE_   COUNTER_BUF_LEN 20 static char/
       /after the       new input is   read, but before processing of the/
       /all output lines\n\   -s, --   squeeze-blank      never more than/
       /argind = optind;    do     {   if (argind < argc)  infile = argv[/
       /be written (according to the   given       options) as the first/
       /binary writes to the console   device.\n\n\ "), stdout); #endif/
       /bpout = stpcpy (bpout, line_   num_print);       }   }         /*/
       /bpout = stpcpy (bpout, line_   num_print);  }        /* Here CH/
       /break;  #if O_BINARY  case '   B':    ++options;    binary_files/
       /byte in the input buffer, i.   e. the      current end of the/
       /cat (      /* Pointer to the   beginning of the input buffer.
       /char *bpin;    /* Pointer to   the first non-valid byte in the/
       /char *bpout;    /* Number of   characters read by the last read/
       /char *inbuf,       /* Number   of characters read in each read/
       /char *infile;  /* Descriptor   on which input file is open.
       /char *line_num_print = line_   buf + LINE_COUNTER_BUF_LEN - 8;  //
       /char *line_num_start = line_   buf + LINE_COUNTER_BUF_LEN - 3;  //
       /check_redirection = 1; #else   int check_redirection = 0; #endif/
       /console output in text mode,   so that LF causes   both CR and LF/
       /do ioctl on `%s'"), infile);   exit_status = 1;         newlines2/
       /else      {        /* It was   a real (not a sentinel) newline.
       /even the implied warranty of   MERCHANTABILITY or FITNESS FOR A/
       /ever read standard input. */   int have_read_stdin = 0;    struct/
       /for those types,      and to   allow things like cat < /dev/tty >/
       /hope that it will be useful,   but WITHOUT ANY WARRANTY; without/
       /i-node numbers of this input   file with   the corresponding/
       /if (argind < argc)  infile =   argv[argind];        if (infile[0]/
       /if (ch != '\n')   *bpout++ =   ch;        else   {     newlines =/
       /ino_t out_ino;    /* Nonzero   if the output file should not be/
       /int binary_files  = 0;   int   binary_output = 0; #endif   int/
       /int check_redirection = 0; #   endif    /* Nonzero if we have/
       /int check_redirection = 1; #   else   int check_redirection = 0;/
       /int mark_line_ends,      int   squeeze_empty_lines) {   /* Last/
       /int newlines = newlines2;  #   ifdef FIONREAD   /* If nonzero,/
       /int newlines2 = 0;  /* Count   of non-fatal error conditions.
       /is a terminal device, and it   is the ONLY    input file (i.e. we/
       /is found,   which means that   the buffer is empty or that a/
       /is in binary mode, make sure   all input files are   also read in/
       /is not done for device files   either. */    if (S_ISREG (stat_/
       /it and/or modify    it under   the terms of the GNU General/
       /line numbering, squeezing of   empty lines or      marking lines'/
       /lines or      marking lines'   ends: then we use text I/O,/
       /makes NEWLINES -1, 1 newline   makes NEWLINES 1,      etc.
       /marking lines' ends: then we   use text I/O, because otherwise/
       /may be written (according to   the given       options) as the/
       /needs about 1000y */ #define   LINE_COUNTER_BUF_LEN 20 static/
       /next_line_num ();    bpout =   stpcpy (bpout, line_num_print);  }/
       /nonblank output lines\n\   -   e                       equivalent/
       /not be done for those types,   and to allow things like cat < //
       /not be the same as any input   file. */ #ifndef _WIN32     int/
       /of     consecutive newlines,   the counter could wrap     around/
       /of cat, the difference    is   especially apparent when using the/
       /of input, we       will have   at most (OUTSIZE - 1 + INSIZE * 4)/
       /on pipes returns S_IFSOCK on   some systems, S_IFIFO      on/
       /one single blank line\n\ "),   stdout);       fputs (_("\   -t/
       /or      marking lines' ends:   then we use text I/O, because/
       /otherwise      -b, -s and -E   would surprise users on DOS//
       /out_ino = 0; #endif     }  #   if O_BINARY   /* We always read/
       /output in text mode, so that   LF causes   both CR and LF on/
       /output is written, at most (   OUTSIZE - 1) bytes will remain in/
       /output.\n\ \n\   -A, --show-   all           equivalent to -vET\n/
       /overflow within an hour on a   P2/466,    an 18 digit counter/
       /preceding block of input was   a       newline, a line number may/
       /Public License    along with   this program; if not, write to the/
       /quote,      int output_tabs,   int numbers,      int numbers_at_/
       /read or written by each read   and write         call.
       /S_IFSOCK on some systems, S_   IFIFO      on others, so the/
       /should not be done for those   types,      and to allow things/
       /simple_cat (      /* Pointer   to the buffer, used by reads and/
       /status) {   if (status != 0)   fprintf (stderr, _("Try `%s --help/
       /stdin to binary switches the   console device to   raw I/O, which/
       /the       new input is read,   but before processing of the input/
       /the `cat' function's local `   newlines' between invocations.
       /the terms of the GNU General   Public License as published by/
       /until a newline character is   found,   which means that the/
       /users on DOS/Windows where a   line      with only CR-LF is an/
       ;        HP-UX returns ENOTTY   on pipes.         /EOPNOTSUPP on NFS
       ;    /* Loop until the end of   the file.        */   ssize_t n_read
       ;    /* Pointer to the output   buffer.             */   char *inbuf
       ^ and M- notation, except for   LFD and TAB\n\ "), stdout);/    /use
       _files)     {       /* Switch   stdout to BINARY mode.    /|| binary
       _LEN - 3;  /* Position of the   last digit in `line_buf'.      /_BUF
       _LEN - 8;  /* Position of the   first digit in `line_buf'.     /_BUF
       _status == 0 ? EXIT_SUCCESS :   EXIT_FAILURE); }    /;    exit (exit
       _stdout);    /* Parse command   line options.    /;    atexit (close
       {       printf (_("\ Usage: %   s [OPTION] [FILE]...\n\ "),/   /else
       }        while (bpout - wp >=   outsize);         /* Move the/    /;
       }    else      {        /* It   was a real (not a sentinel)/   /\n';
       }   exit (status == 0 ? EXIT_   SUCCESS : EXIT_FAILURE); }  /*/   /;
       };    program_name = argv[0];   setlocale (LC_ALL, "");/   /NULL, 0}
       };  /* Position in `line_buf'   where printing starts.    /\t', '\0'
       + (bpout - wp);      }     /*   Is INBUF empty?      /bpout = outbuf
       = outbuf;   }         /* Read   more input into INBUF.        /bpout
       = stat_buf.st_dev;       out_   ino = stat_buf.st_ino;     }/   /dev
       == 0)  break;        /* Write   this block out.          /if (n_read
       2 = 0;  /* Count of non-fatal   error conditions.      /int newlines
       2, or (at your option)    any   later version.     /; either version
       A line number requires seldom   more than LINE_COUNTER_BUF_LEN/
       A newline character is always   put at the end of the buffer, to/
       are at least OUTSIZE bytes in   OUTBUF.           //* Write if there
       beginning of a line, and line   numbers are requested?    /we at the
       behind INPUT_DESC to the file   behind OUTPUT_DESC.    /Cat the file
       both CR and LF on output, and   the output is readable.      /causes
       BPIN > EOB, and thereby input   is read immediately.        /so that
       buffer, i.e. the      current   end of the buffer.     /in the input
       By default, switching console   to binary mode disables SIGINT.
       bytes to the beginning of the   buffer.               /the remaining
       char *buf,       /* Number of   characters preferably read or/    */
       char *inbuf;    /* Pointer to   the output buffer.                */
       char *outbuf,       /* Number   of characters written by each/    */
       char *outbuf;    int c;    /*   Index in argv to processed/       */
       character read from the input   buffer.         /_lines) {   /* Last
       check_redirection = 0; #ifdef   lint  /* Suppress `used before/   /{
       console        to binary mode   disables SIGINT.        /, switching
       corresponding values of the (   output file associated with)/   /the
       could wrap     around at INT_   MAX.                  /, the counter
       counter could wrap     around   at INT_MAX.           /newlines, the
       error (0, errno, _("cannot do   ioctl on `%s'"), infile);/        /{
       Exceptions are when      they   request line numbering, squeezing/
       faster than other versions of   cat, the difference    is/     /much
       file behind INPUT_DESC to the   file behind OUTPUT_DESC.    /Cat the
       file with   the corresponding   values of the (output file/   /input
       files cannot be redirected to   themselves.                    Input
       FIONREAD   /* If nonzero, use   the FIONREAD ioctl, as an/   /#ifdef
       grow by a factor of 4 (by the   prepending of M-^).             /may
       If not, we are about to wait,   so write all buffered output/
       if there are at least OUTSIZE   bytes in OUTBUF.      /{    /* Write
       in the input buffer, i.e. the   current end of the buffer.     /byte
       INPUT_DESC to the file behind   OUTPUT_DESC.    /Cat the file behind
       int c;    /* Index in argv to   processed argument.        /*outbuf;
       it under the terms of the GNU   General Public License as/   /modify
       line numbers to be written at   empty lines (-n)?     /}      /* Are
       line_num_print--; }  /* Plain   cat.                /line_num_print)
       most (OUTSIZE - 1) bytes will   remain in the       buffer.    /, at
       number nonblank output lines\   n\   -e/          /--number-nonblank
       number of the output (file or   whatever).           /;    /* Device
       number, and optimal blocksize   of output.       /Get device, i-node
       of characters written by each   write call.       /,       /* Number
       of this program (e.g., no `g'   prefix).        /* The official name
       output_tabs = 0;    break;  #   if O_BINARY  case 'B':    ++/    /1;
       output_tabs = 1; #if O_BINARY   int binary_files  = 0;   int/   /int
       quote = 1;    break;   case '   u':    /* We provide the -u/   /= 0;
       See the    GNU General Public   License for more details.
       that are set according to the   specified options.     //* Variables
       that have values according to   the specified options.    /Variables
       the      best way to copy the   files verbatim.     /, since this is
       the buffer, used by reads and   writes.               //* Pointer to
       the file behind INPUT_DESC to   the file behind OUTPUT_DESC.    /Cat
       the Free Software Foundation;   either version 2, or (at your/   /by
       the number of lines is larger   than 999999.       /change    unless
       to the beginning of the input   buffer.           /(      /* Pointer
       unless the number of lines is   larger than 999999.      /not change
       want terminal        reads to   be interruptible.             But we
       warning about redefinition on   some systems.    /Undefine, to avoid
       we want terminal        reads   to be interruptible.             But
       when a newline appears in the   input.            /buffer empties or
       when FILE is -, read standard   input.\n\ "), stdout); #if O_/   /or
       WITHOUT ANY WARRANTY; without   even the implied warranty of/   /but
      != 0)     fprintf (stderr, _("   Try `%s --help' for more/   /(status
      #ifdef lint  /* Suppress `used   before initialized' warning.     /0;
      #undef max #define max(h,i) ((   h) > (i) ? (h) : (i))  /* Name/   //
      && optind <= argc)   setmode (   STDOUT_FILENO, O_TEXT);/    /(tty_in
      (bpout - wp);      }     /* Is   INBUF empty?       /bpout = outbuf +
      (i))  /* Name under which this   program was invoked.    /(i) ? (h) :
      )     {       /* Switch stdout   to BINARY mode.     /|| binary_files
      )   *bpout++ = '$';         /*   Output the newline.      /_line_ends
      ); }  /* Compute the next line   number.              /: EXIT_FAILURE
      **argv) {   /* Optimal size of   i/o operations of output.    /, char
      */        if (newlines >= 0 &&   numbers)  {    next_line_num ();/
      */        if (options == 0)  {   insize = max (insize, outsize);/
      */        n_read = safe_read (   input_desc, buf, bufsize);/
      */      char *outbuf,       /*   Number of characters written by/
      */    break;   case 'v':    ++   options;    quote = 1;    break;/
      */    infile = "-";   argind =   optind;    do     {       if (/
      */   char *bpin;    /* Pointer   to the first non-valid byte in the/
      */   char *bpout;    /* Number   of characters read by the last/
      */   int insize;    /* Pointer   to the input buffer.
      */ static char *line_num_end =   line_buf + LINE_COUNTER_BUF_LEN -/
      */ static int exit_status = 0;   void usage (int status) {   if (/
      *bpout++ = ch;        else   {   newlines = -1;     break;   }/   /')
      , but before processing of the   input begins.)    /new input is read
      , i.e. the      current end of   the buffer.     /in the input buffer
      , otherwise call simple_cat to   do the actual work. */   int/   /cat
      , use `cat', otherwise use   `   simple_cat'.       /) were specified
      /' ends: then we use text I/O,   because otherwise      -b, -s and/
      /'B':    ++options;    binary_   files = 1;    break; #endif   case/
      /'T':    ++options;    output_   tabs = 0;    break;   case_GETOPT_/
      /'t':    ++options;    output_   tabs = 0;    quote = 1;    break;/
      /--help) were specified, use `   cat', otherwise use   `simple_cat'/
      /-blank", no_argument, NULL, '   s'},     {"show-nonprinting", no_/
      /"));     } }  /* Cat the file   behind INPUT_DESC to the file/
      /", no_argument, NULL, 'A'}, #   if O_BINARY     {"binary", no_/
      /", no_argument, NULL, 'B'}, #   endif     {GETOPT_HELP_OPTION_DECL/
      /"closeout.h" #include "error.   h" #include "full-write.h" #/
      /#define AUTHORS N_ ("Torbjorn   Granlund and Richard M. Stallman")/
      /#include <stdio.h> #include <   getopt.h> #include <sys/types.h> #/
      /&& close (0) < 0)     error (   EXIT_FAILURE, errno, "-");    exit/
      /();    bpout = stpcpy (bpout,   line_num_print);  }        /* Here/
      /(_("\ Concatenate FILE(s), or   standard input, to standard output/
      /(++newlines > 0)   {     if (   newlines >= 2)       {         /*/
      /(0, errno, _("cannot do ioctl   on `%s'"), infile);         exit_/
      /(ch == 127)       {         *   bpout++ = '^';         *bpout++ =/
      /(fstat (STDOUT_FILENO, &stat_   buf) < 0)     error (EXIT_FAILURE,/
      /(input_desc, FIONREAD, &n_to_   read) < 0)   {     /* Ultrix/
      /(insize, outsize);    inbuf =   xmalloc (insize);     simple_cat (/
      /(numbers && numbers_at_empty_   lines)       {         next_line_/
      /(options == 0)  {    insize =   max (insize, outsize);    inbuf =/
      /(output file associated with)   stdout, and skip this input file/
      /(quote)  {    for (;;)      {   if (ch >= 32)   {     if (ch < 127/
      /(stat_buf);        /* Compare   the device and i-node numbers of/
      /(status == 0 ? EXIT_SUCCESS :   EXIT_FAILURE); }  /* Compute the/
      /(void) {   char *endp = line_   num_end;   do     {       if ((*/
      /)     {       /* If they want   to see the non-printables, let's/
      /);        if (n_read < 0)   {   error (0, errno, "%s", infile);/
      /);       /* When stdout is in   binary mode, make sure all input/
      /);       fputs (_("\ \n\ With   no FILE, or when FILE is -, read/
      /);   default:    usage (EXIT_   FAILURE);  }     }    /* Get/
      /);  }     }    /* Get device,   i-node number, and optimal/
      /)\n\   -v, --show-nonprinting   use ^ and M- notation, except for/
      /* Actual number of characters   read, and therefore written.    /) {
      /* Are multiple adjacent empty   lines to be substituted     by/   /;
      /* Output a currency symbol if   requested (-e).               /}   }
      /* Pointer to the beginning of   the input buffer.        /void cat (
      /* Pointer to the beginning of   the output buffer.      /int insize,
      /* Pointer to the buffer, used   by reads and writes.         /_cat (
      /* Position of the first digit   in `line_buf'.        /_BUF_LEN - 8;
      /* Switch stdin to BINARY mode   if needed.          /;  #if O_BINARY
      /* Write if there are at least   OUTSIZE bytes in OUTBUF.      /do  {
      /, 'E'},     {"show-tabs", no_   argument, NULL, 'T'},     {"show-/
      /, 'n'},     {"squeeze-blank",   no_argument, NULL, 's'},     {"/
      /, 'v'},     {"show-ends", no_   argument, NULL, 'E'},     {"show-/
      /, "%s", infile);        exit_   status = 1;        continue;/
      /, &n_to_read) < 0)   {     /*   Ultrix returns EOPNOTSUPP on NFS;/
      /, &stat_buf) < 0)     error (   EXIT_FAILURE, errno, _("standard/
      /, _("Try `%s --help' for more   information.\n"),       program_/
      /, and it is the ONLY    input   file (i.e. we didn't write/
      /, at most (OUTSIZE - 1) bytes   will remain in the       buffer.
      /, buf, bufsize);       if (n_   read < 0)  {    error (0, errno, "/
      /, char **argv) {   /* Optimal   size of i/o operations of output.
      /, errno, "-");    exit (exit_   status == 0 ? EXIT_SUCCESS : EXIT_/
      /, if they ask for      one of   these options, they don't care/
      /, inbuf, insize);        if (   n_read < 0)   {     error (0,/
      /, n_read) != n_read)  error (   EXIT_FAILURE, errno, _("write/
      /, O_TEXT);     } #endif    /*   Check if any of the input files/
      /, quote,         output_tabs,   numbers, numbers_at_empty_lines,/
      /, since this is the      best   way to copy the files verbatim.
      /, so that LF causes   both CR   and LF on output, and the output/
      /, squeezing of empty lines or   marking lines' ends: then we use/
      /, switching console        to   binary mode disables SIGINT.
      /, to make    an explicit test   for buffer end unnecessary.
      /, we are about to wait,    so   write all buffered output before/
      /. If any options (more than -   u,   --version, or --help) were/
      /.h"   /* The official name of   this program (e.g., no `g' prefix)/
      /.h" #include "full-write.h" #   include "safe-read.h"   /* The/
      /.h> #endif  #include "system.   h" #include "closeout.h" #include/
      //* Cat the file behind INPUT_   DESC to the file behind OUTPUT_/
      //* Get device, i-node number,   and optimal blocksize of output.
      //* Undefine, to avoid warning   about redefinition on some systems/
      //* Variables that have values   according to the specified options/
      /;         return;       }   }   if (n_to_read == 0) #endif   {/
      /;        do   {     if (full_   write (STDOUT_FILENO, wp, outsize)/
      /;     return;   }        if (   n_read == 0)   {     newlines2 =/
      /;    /* Nonzero if the output   file should not be the same as any/
      /;    numbers = 1;    numbers_   at_empty_lines = 0;    break;/
      /;    quote = 1;    mark_line_   ends = 1;    output_tabs = 0;/
      /;    squeeze_empty_lines = 1;   break;   case 't':    ++options;/
      /_buf);   /* Input file can be   output file for non-regular files.
      /_BUF_LEN - 3;  /* Position of   the last digit in `line_buf'.
      /_BUF_LEN - 8;  /* Position of   the first digit in `line_buf'.
      /_BUF_LEN 20 static char line_   buf[LINE_COUNTER_BUF_LEN] =   {/
      /_cat (      /* Pointer to the   buffer, used by reads and writes.
      /_CHAR;   case_GETOPT_VERSION_   CHAR (PROGRAM_NAME, AUTHORS);/
      /_COUNTER_BUF_LEN)       bytes   allocated for the output buffer?
      /_empty_lines = 0;   int mark_   line_ends = 0;   int quote = 0;/
      /_end;   do     {       if ((*   endp)++ < '9')  return;       */
      /_ends = 1;    break;   case '   T':    ++options;    output_tabs =/
      /_ends,         squeeze_empty_   lines);     free (outbuf);  }/
      /_FAILURE);  }     }    /* Get   device, i-node number, and optimal/
      /_ino = stat_buf.st_ino;     }   else     {       check_redirection/
      /_LEN - 3;  /* Preserves the `   cat' function's local `newlines'/
      /_LEN 20 static char line_buf[   LINE_COUNTER_BUF_LEN] =   {     '/
      /_line_ends = 1;    quote = 1;   break;   case 'n':    ++options;/
      /_line_ends))       || binary_   files)     {       /* Switch/
      /_line_ends,      int squeeze_   empty_lines) {   /* Last character/
      /_line_num ();         bpout =   stpcpy (bpout, line_num_print);/
      /_lines)       {         next_   line_num ();         bpout =/
      /_lines) {   /* Last character   read from the input buffer.
      /_mode |= O_BINARY;       SET_   BINARY (0);        /* Setting/
      /_num_print = line_buf + LINE_   COUNTER_BUF_LEN - 8;  /* Position/
      /_num_start = line_buf + LINE_   COUNTER_BUF_LEN - 3;  /* Position/
      /_open_mode |= O_BINARY;     }   else if (quote)     {       /* If/
      /_open_mode = O_RDONLY;  /* If   nonzero, call cat, otherwise call/
      /_OPTION_DESCRIPTION, stdout);   fputs (_("\ \n\ With no FILE, or/
      /_OPTION_DESCRIPTION, stdout);   fputs (VERSION_OPTION_DESCRIPTION,/
      /_options, NULL)) != -1)     {   switch (c)  {  case 0:    break;/
      /_POSIX_SOURCE # include <sys/   ioctl.h> #endif  #include "system./
      /_print);  }        /* Here CH   cannot contain a newline character/
      /_read_stdin && close (0) < 0)   error (EXIT_FAILURE, errno, "-");/
      /_redirection = 1; #else   int   check_redirection = 0; #endif    //
      /_SOURCE # include <sys/ioctl.   h> #endif  #include "system.h" #/
      /_status = 0;  void usage (int   status) {   if (status != 0)/
      /_tabs = 1; #if O_BINARY   int   binary_files  = 0;   int binary_/
      /{      *bpout++ = '^';      *   bpout++ = ch - 128 + 64;    }/
      /{     {"number-nonblank", no_   argument, NULL, 'b'},     {"number/
      /{     if (full_write (STDOUT_   FILENO, wp, outsize) != outsize)/
      /{    /* Write if there are at   least OUTSIZE bytes in OUTBUF.
      /{  case 0:    break;   case '   b':    ++options;    numbers = 1;/
      /|| errno == ENOTTY         ||   errno == EINVAL || errno == ENODEV/
      /}        if (n_read == 0)   {   newlines2 = newlines;     return;/
      /}       insize = ST_BLKSIZE (   stat_buf);        /* Compare the/
      /}      /* Are line numbers to   be written at empty lines (-n)?
      /}  }        if (fstat (input_   desc, &stat_buf) < 0)  {    error/
      /++ = ch + 64;   }        else   if (ch != '\n')   *bpout++ = ch;/
      /<sys/types.h> #ifndef _POSIX_   SOURCE # include <sys/ioctl.h> #/
      /= '>';   if (line_num_start <   line_num_print)     line_num_print/
      /= 0;    break;   case_GETOPT_   HELP_CHAR;   case_GETOPT_VERSION_/
      /= 0;   int output_tabs = 1; #   if O_BINARY   int binary_files  =/
      /= 2;          /* Are multiple   adjacent empty lines to be/
      /= eob + 1;    bpout = outbuf;   for (;;)     {       do  {    /*/
      /= safe_read (input_desc, buf,   bufsize);       if (n_read < 0)  {/
      /= ST_BLKSIZE (stat_buf);   /*   Input file can be output file for/
      /== '\n');        /* Are we at   the beginning of a line, and line/
      /== ENOTTY         || errno ==   EINVAL || errno == ENODEV # ifdef/
      /> eob)      { #ifdef FIONREAD   int n_to_read = 0;         /* Is/
      /11 digit counter may overflow   within an hour on a P2/466,    an/
      /2 = newlines;     return;   }   if (n_read == 0)   {     newlines2/
      /20 static char line_buf[LINE_   COUNTER_BUF_LEN] =   {     ' ', '/
      /a newline character is found,   which means that the buffer is/
      /allow things like cat < /dev/   tty > /dev/tty, checking      is/
      /an hour on a P2/466,    an 18   digit counter needs about 1000y *//
      /and Richard M. Stallman")  /*   Undefine, to avoid warning about/
      /and/or modify    it under the   terms of the GNU General Public/
      /be useful,    but WITHOUT ANY   WARRANTY; without even the implied/
      /binary_files = 1;    break; #   endif   case 'E':    ++options;/
      /binary_output = 1;       SET_   BINARY (STDOUT_FILENO);       /*/
      /block of input, we       will   have at most (OUTSIZE - 1 + INSIZE/
      /bufsize) {   /* Actual number   of characters read, and therefore/
      /ch;    /* Pointer to the next   character in the input buffer.
      /char ch;    /* Pointer to the   next character in the input buffer/
      /character       may grow by a   factor of 4 (by the prepending of/
      /characters preferably read or   written by each read and write/
      /contin;  }       insize = ST_   BLKSIZE (stat_buf);        /*/
      /display TAB characters as ^I\   n\   -u                       (/
      /do, and no newlines appear in   this block of input, we       will/
      /else     {       printf (_("\   Usage: %s [OPTION] [FILE]...\n\ ")/
      /empty lines to be substituted   by single ditto (-s), and this was/
      /eob = bpin + n_read;        *   eob = '\n';      }    else      {/
      /EOPNOTSUPP on NFS;        HP-   UX returns ENOTTY on pipes.
      /equivalent to -vE\n\   -E, --   show-ends          display $ at/
      /equivalent to -vT\n\   -T, --   show-tabs          display TAB/
      /error"));     } }  /* Cat the   file behind INPUT_DESC to the file/
      /FILE, or when FILE is -, read   standard input.\n\ "), stdout); #/
      /found,   which means that the   buffer is empty or that a proper/
      /Foundation; either version 2,   or (at your option)    any later/
      /fputs (_("\ \n\ With no FILE,   or when FILE is -, read standard/
      /fputs (_("\ Concatenate FILE(   s), or standard input, to standard/
      /GNU General Public License as   published by    the Free Software/
      /how many consecutive newlines   there have been in the      input.
      /I/O, because otherwise      -   b, -s and -E would surprise users/
      /if (bpin > eob)      { #ifdef   FIONREAD        int n_to_read = 0;/
      /if (fstat (input_desc, &stat_   buf) < 0)  {    error (0, errno, "/
      /if (squeeze_empty_lines)    {   ch = *bpin++;      continue;    }/
      /if (tty_in && optind <= argc)   setmode (STDOUT_FILENO, O_TEXT);/
      /if any of the input files are   the same as the output file.
      /if the output file should not   be the same as any input file. *//
      /if we have ever read standard   input. */   int have_read_stdin =/
      /in binary mode, make sure all   input files are   also read in/
      /in BINARY mode, since this is   the      best way to copy the/
      /input       buffer empties or   when a newline appears in the/
      /input file. */ #ifndef _WIN32   int check_redirection = 1; #else/
      /input.\n\ "), stdout); #if O_   BINARY       fputs (_("\ \n\   -B,/
      /int binary_output = 0; #endif   int file_open_mode = O_RDONLY;  /*/
      /int mark_line_ends = 0;   int   quote = 0;   int output_tabs = 1;/
      /int n_to_read = 0;         /*   Is there any input to read/
      /is so "cat > xyzzy" creates a   DOS-style text    file, like/
      /is the ONLY    input file (i.   e. we didn't write anything to the/
      /LF causes   both CR and LF on   output, and the output is readable/
      /lines' ends: then we use text   I/O, because otherwise      -b, -s/
      /mark_line_ends = 1;    break;   case 'T':    ++options;    output_/
      /max #define max(h,i) ((h) > (   i) ? (h) : (i))  /* Name under/
      /max(h,i) ((h) > (i) ? (h) : (   i))  /* Name under which this/
      /may grow by a factor of 4 (by   the prepending of M-^).
      /multiple adjacent empty lines   to be substituted     by single/
      /new input is read, but before   processing of the input begins.)
      /newline, a line number may be   written (according to the given/
      /newlines = -1;     break;   }   ch = *bpin++;      }  }     } }/
      /newlines = -1;     break;   }   else   {     *bpout++ = '^';     */
      /newlines = 2;          /* Are   multiple adjacent empty lines to/
      /newlines = newlines2;  #ifdef   FIONREAD   /* If nonzero, use the/
      /newlines appear in this block   of input, we       will have at/
      /numbering, squeezing of empty   lines or      marking lines' ends:/
      /numbers,      int numbers_at_   empty_lines,      int mark_line_/
      /of characters preferably read   or written by each read and write/
      /of input was a       newline,   a line number may be written (/
      /of this input file with   the   corresponding values of the (/
      /options = 0;    static struct   option const long_options[] =   {/
      /options, they don't care much   about the original      file/
      /output file should not be the   same as any input file. */ #ifndef/
      /output needs to be written is   done when the input       buffer/
      /preferably read or written by   each read and write         call.
      /program is distributed in the   hope that it will be useful,/
      /program is free software; you   can redistribute it and/or modify/
      /program; if not, write to the   Free Software Foundation,    Inc.,/
      /put at the end of the buffer,   to make    an explicit test for/
      /quote = 1;    break;   case '   A':    ++options;    quote = 1;/
      /quote = 1;    break;   case '   n':    ++options;    numbers = 1;/
      /read standard input. */   int   have_read_stdin = 0;    struct/
      /redistribute it and/or modify   it under the terms of the GNU/
      /return;   }         /* Update   the pointers and insert a sentinel/
      /see the non-printables, let's   show them   those CR characters as/
      /should not be the same as any   input file. */ #ifndef _WIN32/
      /some systems, S_IFIFO      on   others, so the checking should not/
      /surprise users on DOS/Windows   where a line      with only CR-LF/
      /the buffer is empty or that a   proper newline   has been found.
      /the device and i-node numbers   of this input file with   the/
      /the first thing in the output   buffer. (Done after the       new/
      /the Free Software Foundation,   Inc., 59 Temple Place - Suite 330,/
      /the output file should not be   the same as any input file. */ #/
      /them   those CR characters as   well, so make the input binary.
      /thing in the output buffer. (   Done after the       new input is/
      /to the    output yet), switch   the output back to TEXT mode.
      /use ^ and M- notation, except   for LFD and TAB\n\ "), stdout);/
      /void cat (      /* Pointer to   the beginning of the input buffer.
      /while (ch == '\n');        /*   Are we at the beginning of a line,/
      /will not change    unless the   number of lines is larger than 999/
      /with)   stdout, and skip this   input file if they coincide.
      : EXIT_FAILURE); }  /* Compute   the next line number.      /_SUCCESS
      ;       out_ino = stat_buf.st_   ino;     }   else     {/    /.st_dev
      _BINARY (0);        /* Setting   stdin to binary switches the/   /SET
      _BLKSIZE (stat_buf);        /*   Compare the device and i-node/   /ST
      _GETOPT_VERSION_CHAR (PROGRAM_   NAME, AUTHORS);   default:/    /case
      _LEN);     cat (inbuf, insize,   outbuf, outsize, quote,/       /_BUF
      _lines);     free (outbuf);  }   free (inbuf);      contin:/   /empty
      _num_print);  }        /* Here   CH cannot contain a newline/   /line
      {        /* It was a real (not   a sentinel) newline.      /}    else
      {       /* If they want to see   the non-printables, let's show/   /)
      }         /* Output a currency   symbol if requested (-e).         /}
      }        if (n_to_read == 0) #   endif   {     size_t n_write =/   /}
      }       }   }        else if (   ch == '\t' && output_tabs)   */   /;
      },     {NULL, 0, NULL, 0}   };   program_name = argv[0];/      /_DECL
      < 128 + 127)        *bpout++ =   ch - 128;      else        {/   /(ch
      >= 2)       {         /* Limit   this to 2 here.        /if (newlines
      0)  {    insize = max (insize,   outsize);    inbuf = xmalloc (/   /=
      0:    break;   case 'b':    ++   options;    numbers = 1;/   /{  case
      1;    break;   case 't':    ++   options;    output_tabs = 0;/     /=
      1;    break;   case 'T':    ++   options;    output_tabs = 0;/     /=
      1;    break;   case 'u':    /*   We provide the -u feature/        /=
      1;    return;  }        /* End   of this file?    /;    exit_status =
      a DOS-style text    file, like   people expect.     /> xyzzy" creates
      a line      with only CR-LF is   an empty line.    /DOS/Windows where
      a line number may be written (   according to the given/    /newline,
      A test whether output needs to   be written is done when the input/
      After       output is written,   at most (OUTSIZE - 1) bytes will/
      and thereby input      is read   immediately.       /that BPIN > EOB,
      any of the input files are the   same as the output file.         /if
      ANY WARRANTY; without even the   implied warranty of/    /but WITHOUT
      Are line numbers to be written   at empty lines (-n)?      /}      /*
      at the beginning of a      new   line.                   /that we are
      be output file for non-regular   files.            //* Input file can
      before processing of the input   begins.)         /input is read, but
      behind `input_desc' to STDOUT_   FILENO.              Copies the file
      BINARY mode, since this is the   best way to copy the files/      /in
      bpout = outbuf;   }         /*   Read more input into INBUF.    /"));
      bytes allocated for the output   buffer?                   /_BUF_LEN)
      cat:    * Always unbuffered, -   u is ignored.         /from the Unix
      change    unless the number of   lines is larger than 999999.    /not
      characters read, and therefore   written.         /* Actual number of
      concatenate files and print on   the standard output.       /* cat --
      Copies the file behind `input_   desc' to STDOUT_FILENO.
      CR characters as well, so make   the input binary.      /them   those
      Descriptor on which input file   is open.          /char *infile;  /*
      display $ at end of each line\   n\   -n, --number/       /-show-ends
      Each input character       may   grow by a factor of 4 (by the/
      else      {        /* It was a   real (not a sentinel) newline.    /}
      else if (ch == '\t' && output_   tabs)   *bpout++ = '\t';/     /}   }
      else if (quote)     {       /*   If they want to see the non-/     /}
      empty or that a proper newline   has been found.       /the buffer is
      EOB, and thereby input      is   read immediately.    /so that BPIN >
      errno, "%s", infile);    exit_   status = 1;    goto contin;  }/   /,
      especially apparent when using   the -v option.     /difference    is
      exit (exit_status == 0 ? EXIT_   SUCCESS : EXIT_FAILURE); }    /"-");
      factor of 4 (by the prepending   of M-^).              /may grow by a
      for (;;)     {       /* Read a   block of input.                   */
      Get device, i-node number, and   optimal blocksize of output.     //*
      GNU General Public License for   more details.                See the
      have_read_stdin = 1;    input_   desc = 0;  #if O_BINARY    /*/    /{
      I/O, which also affects stdout   to console.         /device to   raw
      if (ch < 127)       *bpout++ =   ch;     else if (ch == 127)/      /{
      if (full_write (STDOUT_FILENO,   outbuf, n_write) != n_write)/     /;
      if (full_write (STDOUT_FILENO,   wp, outsize) != outsize)/    /do   {
      if (status != 0)     fprintf (   stderr, _("Try `%s --help' for/   /{
      if any option more than -u was   specified.                    Called
      ifdef __DJGPP__     /* This is   DJGPP-specific.     /(input_desc); #
      input character       may grow   by a factor of 4 (by the/       Each
      input files are   also read in   binary mode.        /, make sure all
      insize * 4 + LINE_COUNTER_BUF_   LEN);     cat (inbuf, insize,/    /+
      int input_desc;  /* Buffer for   line numbers.              */ static
      is read, but before processing   of the input begins.)     /new input
      It was a real (not a sentinel)   newline.                /{        /*
      lint  /* Suppress `used before   initialized' warning.     /0; #ifdef
      MERCHANTABILITY or FITNESS FOR   A PARTICULAR PURPOSE.            /of
      more consecutive newlines been   read?)             (i.e. have two or
      more than LINE_COUNTER_BUF_LEN   positions.                   /seldom
      NULL, 'b'},     {"number", no_   argument, NULL, 'n'},     {"/     /,
      number of characters read, and   therefore written.    /{   /* Actual
      numbers to be written at empty   lines (-n)?      /}      /* Are line
      O_BINARY    /* Switch stdin to   BINARY mode if needed.    /= 0;  #if
      of characters read by the last   read call.           /;    /* Number
      of the procedure is determined   by      NEWLINES.        The "state"
      on special files        like /   dev/null.       //BSD returns ENODEV
      open (infile, file_open_mode);   if (input_desc < 0)      {/       /=
      Optimal size of i/o operations   of input.        /int outsize;    /*
      Optimal size of i/o operations   of output.           /**argv) {   /*
      optind;    do     {       if (   argind < argc)  infile = argv[/   /=
      or that a proper newline   has   been found.         /buffer is empty
      others, so the checking should   not be done for those types,/    /on
      outbuf;        do   {     if (   full_write (STDOUT_FILENO, wp,/   /=
      output yet), switch the output   back to TEXT mode.           /to the
      output_tabs = 0;    quote = 1;   break;   case 'u':    /* We/      /;
      output_tabs,      int numbers,   int numbers_at_empty_lines,/    /int
      outsize;    /* Optimal size of   i/o operations of input.    //   int
      Pointer to the buffer, used by   reads and writes.    /_cat (      /*
      pointers and insert a sentinel   at the buffer    end.    /Update the
      Preserves the `cat' function's   local `newlines' between/    /3;  /*
      read, but before processing of   the input begins.)     /new input is
      set according to the specified   options.         /Variables that are
      stdout);       fputs (VERSION_   OPTION_DESCRIPTION, stdout);/     /,
      Switch stdin to BINARY mode if   needed.          /#if O_BINARY    /*
      switch the output back to TEXT   mode.                  /output yet),
      the    output yet), switch the   output back to TEXT mode.        /to
      the GNU General Public License   as published by    the Free/     /of
      The loops below continue until   a newline character is found,/   //*
      the procedure is determined by   NEWLINES.             The "state" of
      they ask for      one of these   options, they don't care much/   /if
      This program is distributed in   the hope that it will be useful,/
      This program is free software;   you can redistribute it and/or/
      This will not change    unless   the number of lines is larger than/
      to indicate that we are at the   beginning of a      new line.     /0
      to the beginning of the output   buffer.          /,       /* Pointer
      Ultrix, it is not supported on   NFS filesystems.)                (On
      version 2, or (at your option)   any later version.         /; either
      wait,    so write all buffered   output before waiting.     /about to
      When stdout is in binary mode,   make sure all input files are/   //*
      where the next character shall   be written.         /to the position
      which means that the buffer is   empty or that a proper newline/   /,
      while ((c = getopt_long (argc,   argv, #if O_BINARY       "/       */
      wp);        bpout = outbuf + (   bpout - wp);      }     /* Is/    /-
      writes to the console device.\   n\n\ "), stdout); #endif/    /binary
      written by each read and write   call.                       /read or
      written, at most (OUTSIZE - 1)   bytes will remain in the/        /is
     "), stdout);       fputs (HELP_   OPTION_DESCRIPTION, stdout);/   /\n\
     ", no_argument, NULL, 'A'}, #if   O_BINARY     {"binary", no_/   /-all
     "number-nonblank", no_argument,   NULL, 'b'},     {"number", no_/   /{
     #endif   {     size_t n_write =   bpout - outbuf;      if (full_/   /)
     #if O_BINARY    /* Switch stdin   to BINARY mode if needed.      /= 0;
     #include <config.h>  #include <   stdio.h> #include <getopt.h> #/   //
     &stat_buf) < 0)  {    error (0,   errno, "%s", infile);    exit_/   /,
     ("Torbjorn Granlund and Richard   M. Stallman")  /* Undefine, to/   /_
     (ch < 127)       *bpout++ = ch;   else if (ch == 127)       {/     /if
     (h) : (i))  /* Name under which   this program was invoked.     /(i) ?
     (h) > (i) ? (h) : (i))  /* Name   under which this program was/   /) (
     (n_read == 0)  break;        /*   Write this block out.            /if
     (On Ultrix, it is not supported   on NFS filesystems.)
     (OUTSIZE - 1) bytes will remain   in the       buffer.      /, at most
     (stderr, _("Try `%s --help' for   more information.\n"),/     /fprintf
     )       {         /* Limit this   to 2 here.        /if (newlines >= 2
     )       bytes allocated for the   output buffer?     /_COUNTER_BUF_LEN
     )     {       do  {    /* Write   if there are at least OUTSIZE/   /;;
     )   stdout, and skip this input   file if they coincide.         /with
     ); # endif   }      } #endif  }   else  {    input_desc = open (/   /1
     * Device number of the output (   file or whatever).     /argind;    /
     * Input file can be output file   for non-regular files.    /buf);   /
     * Name under which this program   was invoked.     /i) ? (h) : (i))  /
     * Not quoting, neither of -v, -   e, or -t specified.    /else  {    /
     * Pointer to the next character   in the input buffer.       /ch;    /
     * Pointer to the position where   the next character shall be/      //
     * Preserves the `cat' function'   s local `newlines' between/   /3;  /
     */         /* Was the last line   empty?
     */         memmove (outbuf, wp,   bpout - wp);        bpout = outbuf/
     */         n_read = safe_read (   input_desc, inbuf, insize);/
     */      if (numbers && numbers_   at_empty_lines)       {/
     */     if (bpin > eob)      { #   ifdef FIONREAD        int n_to_/
     */    if (binary_output)      {   int tty_in = isatty (input_desc);/
     */    while ((c = getopt_long (   argc, argv, #if O_BINARY       "/
     */   char *inbuf;    /* Pointer   to the output buffer.
     */   int outsize;    /* Optimal   size of i/o operations of input.
     */   ssize_t n_read;    /* Loop   until the end of the file.
     */  static void next_line_num (   void) {   char *endp = line_num_/
     */ char *program_name;  /* Name   of input file.
     ,       /* Number of characters   read in each read call.      /*inbuf
     ,      and to allow things like   cat < /dev/tty > /dev/tty,/   /types
     , and this was the second empty   line?                    /ditto (-s)
     , make sure all input files are   also read in binary mode.      /mode
     , Torbjorn Granlund, advised by   rms, Richard Stallman. */  #/   /.se
     , use the FIONREAD ioctl, as an   optimization.         //* If nonzero
     ., 59 Temple Place - Suite 330,   Boston, MA 02111-1307, USA.     /Inc
     .e. the      current end of the   buffer.             /input buffer, i
     .e. we didn't write anything to   the    output yet), switch the/   /i
     /' to use. If any options (more   than -u,   --version, or --help)/
     /'B'}, #endif     {GETOPT_HELP_   OPTION_DECL},     {GETOPT_VERSION_/
     /'s':    ++options;    squeeze_   empty_lines = 1;    break;   case/
     /'s'},     {"show-nonprinting",   no_argument, NULL, 'v'},     {"/
     /--help' for more information.\   n"),       program_name);   else/
     /--show-ends          display $   at end of each line\n\   -n, --/
     /--show-nonprinting   use ^ and   M- notation, except for LFD and/
     /-, read standard input.\n\ "),   stdout); #if O_BINARY       fputs/
     /-all           equivalent to -   vET\n\   -b, --number-nonblank/
     /-s, --squeeze-blank      never   more than one single blank line\n\/
     /-v, --show-nonprinting   use ^   and M- notation, except for LFD/
     /-write.h" #include "safe-read.   h"   /* The official name of this/
     /        /* If quoting, i.e. at   least one of -v, -e, or -t/        *
     /       out_dev = 0;       out_   ino = 0; #endif     }  #if O_/     *
     /   char *eob;    /* Pointer to   the position where the next/       *
     /   dev_t out_dev;    /* I-node   number of the output.              *
     / #define PROGRAM_NAME "cat"  #   define AUTHORS N_ ("Torbjorn/      *
     / static int newlines2 = 0;  /*   Count of non-fatal error/          *
     /!= n_write)       error (EXIT_   FAILURE, errno, _("write error"));/
     /!= outsize)       error (EXIT_   FAILURE, errno, _("write error"));/
     /" #endif       , long_options,   NULL)) != -1)     {       switch (/
     /"));    outsize = ST_BLKSIZE (   stat_buf);   /* Input file can be/
     /"full-write.h" #include "safe-   read.h"   /* The official name of/
     /"system.h" #include "closeout.   h" #include "error.h" #include "/
     /#include "system.h" #include "   closeout.h" #include "error.h" #/
     /#include <getopt.h> #include <   sys/types.h> #ifndef _POSIX_SOURCE/
     /&& !(numbers || squeeze_empty_   lines || mark_line_ends))       ||/
     /&& infile[1] == 0)  {    have_   read_stdin = 1;    input_desc = 0;/
     /(C) 88, 90, 91, 1995-2002 Free   Software Foundation, Inc.
     /(ch == '\n');        /* Are we   at the beginning of a line, and/
     /(check_redirection    && stat_   buf.st_dev == out_dev && stat_buf./
     /(EXIT_FAILURE);  }     }    /*   Get device, i-node number, and/
     /(EXIT_FAILURE, errno, _("write   error"));     } }  /* Cat the file/
     /(EXIT_FAILURE, errno, _("write   error"));     bpout = outbuf;   }/
     /(EXIT_FAILURE, errno, _("write   error"));     wp += outsize;   }/
     /(i.e. we didn't write anything   to the    output yet), switch the/
     /(infile, "-") && close (input_   desc) < 0)  {    error (0, errno,/
     /(insize + 1);     /* Why are (   OUTSIZE - 1 + INSIZE * 4 + LINE_/
     /(int argc, char **argv) {   /*   Optimal size of i/o operations of/
     /(n_read < 0)   {     error (0,   errno, "%s", infile);     exit_/
     /(quote)     {       /* If they   want to see the non-printables,/
     /(STDOUT_FILENO);       /* When   stdout is in binary mode, make/
     /)     *--line_num_start = '1';   else     *line_buf = '>';   if (/
     /)   setmode (STDOUT_FILENO, O_   TEXT);        else   {     SET_/
     /))     {       out_dev = stat_   buf.st_dev;       out_ino = stat_/
     /))  setmode (STDOUT_FILENO, O_   TEXT);     } #endif    /* Check if/
     /)) != -1)     {       switch (   c)  {  case 0:    break;   case 'b/
     /);     }   exit (status == 0 ?   EXIT_SUCCESS : EXIT_FAILURE); }  //
     /);     } #endif    /* Check if   any of the input files are the/
     /);    exit_status = 1;    goto   contin;  }        /* Select which/
     /);    exit_status = 1;    goto   contin;  }       insize = ST_/
     /);  }        /* Here CH cannot   contain a newline character.
     /);  }       else  {    inbuf =   xmalloc (insize + 1);     /* Why/
     /* Are we at the beginning of a   line, and line numbers are/   /\n');
     /* cat -- concatenate files and   print on the standard output.
     /* If they want to see the non-   printables, let's show them/      /{
     /* Last character read from the   input buffer.       /_empty_lines) {
     /* Number of characters read by   the last read call.    /char *bpout;
     /* Number of characters read in   each read call.             /*inbuf,
     /* Number of characters written   by each write call.        /*outbuf,
     /* Position in `line_buf' where   printing starts.    /'\t', '\0'   };
     /*bpout++ = '^';     *bpout++ =   ch + 64;   }         ch = *bpin++;/
     /*bpout++ = '^';     *bpout++ =   ch + 64;   }        else if (ch !=/
     /*endp-- = '0';     }   while (   endp >= line_num_start);   if (/
     /*outbuf;    int c;    /* Index   in argv to processed argument.
     /,       /* Variables that have   values according to the specified/
     /,    but WITHOUT ANY WARRANTY;   without even the implied warranty/
     /, _("write error"));     wp +=   outsize;   }        while (bpout -/
     /, 0, NULL, 0}   };    program_   name = argv[0];   setlocale (LC_/
     /, i.e. at least one of -v, -e,   or -t specified,   scan for chars/
     /, NULL, 'T'},     {"show-all",   no_argument, NULL, 'A'}, #if O_/
     /, outbuf, n_write) != n_write)   error (EXIT_FAILURE, errno, _("/
     /, stdout);       fputs (_("\ \   n\ With no FILE, or when FILE is -/
     /, we       will have at most (   OUTSIZE - 1 + INSIZE * 4) bytes in/
     /, with lots of     consecutive   newlines, the counter could wrap/
     /. */    if (S_ISREG (stat_buf.   st_mode))     {       out_dev =/
     /.\n\ "), stdout); #if O_BINARY   fputs (_("\ \n\   -B, --binary/
     /.st_dev;       out_ino = stat_   buf.st_ino;     }   else     {/
     //* Move the remaining bytes to   the beginning of the    buffer.
     //* We always read and write in   BINARY mode, since this is the/
     //BSD returns ENODEV on special   files        like /dev/null.
     //dev/tty, checking      is not   done for device files either. *//
     /: %s [OPTION] [FILE]...\n\ "),   program_name);       fputs (_("\/
     /;       }   }        if (n_to_   read == 0) #endif   {     size_t n/
     /;      }  }        if (fstat (   input_desc, &stat_buf) < 0)  {/
     /;      if (full_write (STDOUT_   FILENO, outbuf, n_write) != n_/
     /;    /* Variables that are set   according to the specified options/
     /;   bpin = eob + 1;    bpout =   outbuf;    for (;;)     {       do/
     /;   case 'u':    /* We provide   the -u feature unconditionally.
     /;   case_GETOPT_VERSION_CHAR (   PROGRAM_NAME, AUTHORS);   default:/
     /; you can redistribute it and/   or modify    it under the terms of/
     /[0];   setlocale (LC_ALL, "");   bindtextdomain (PACKAGE, LOCALEDIR/
     /\n\ "), stdout);       fputs (   HELP_OPTION_DESCRIPTION, stdout);/
     /\n\ With no FILE, or when FILE   is -, read standard input.\n\ "),/
     /_("write error"));     } }  /*   Cat the file behind INPUT_DESC to/
     /_("write error"));     bpout =   outbuf;   }         /* Read more/
     /_at_empty_lines = 0;    break;   case 'e':    ++options;    mark_/
     /_buf.st_ino == out_ino    && (   input_desc != STDIN_FILENO))  {/
     /_buf;    /* Variables that are   set according to the specified/
     /_cat to do the actual work. */   int options = 0;    static struct/
     /_CHAR (PROGRAM_NAME, AUTHORS);   default:    usage (EXIT_FAILURE);/
     /_desc = 0;  #if O_BINARY    /*   Switch stdin to BINARY mode if/
     /_desc);         /* If stdin is   a terminal device, and it is the/
     /_dev = 0;       out_ino = 0; #   endif     }  #if O_BINARY   /* We/
     /_empty_lines)    {      ch = *   bpin++;      continue;    }/
     /_ends = 1;    output_tabs = 0;   break;  #if O_BINARY  case 'B':/
     /_ends,      int squeeze_empty_   lines) {   /* Last character read/
     /_FILENO);       /* When stdout   is in binary mode, make sure all/
     /_fionread     && ioctl (input_   desc, FIONREAD, &n_to_read) < 0)/
     /_ino = 0; #endif     }  #if O_   BINARY   /* We always read and/
     /_lines = 0;    break;   case '   e':    ++options;    mark_line_/
     /_lines = 1;    break;   case '   t':    ++options;    output_tabs =/
     /_name = argv[0];   setlocale (   LC_ALL, "");   bindtextdomain (/
     /_num_start = '1';   else     *   line_buf = '>';   if (line_num_/
     /_num_start > line_buf)     *--   line_num_start = '1';   else     */
     /_options[] =   {     {"number-   nonblank", no_argument, NULL, 'b'}/
     /_read = 0;         /* Is there   any input to read immediately?
     /_redirection = 0; #endif    /*   Nonzero if we have ever read/
     /_write (STDOUT_FILENO, buf, n_   read) != n_read)  error (EXIT_/
     /_write (STDOUT_FILENO, outbuf,   n_write) != n_write)       error (/
     /`%s'"), infile);         exit_   status = 1;         newlines2 =/
     /`cat' to use. If any options (   more than -u,   --version, or --/
     /{         error (0, errno, _("   cannot do ioctl on `%s'"), infile)/
     /{        int tty_in = isatty (   input_desc);         /* If stdin/
     /{       out_dev = stat_buf.st_   dev;       out_ino = stat_buf.st_/
     /{       switch (c)  {  case 0:   break;   case 'b':    ++options;/
     /{     size_t n_write = bpout -   outbuf;      if (full_write (/
     /{    error (0, 0, _("%s: input   file is output file"), infile);/
     /{   char *endp = line_num_end;   do     {       if ((*endp)++ < '9'/
     /{"squeeze-blank", no_argument,   NULL, 's'},     {"show-nonprinting/
     /|| errno == EINVAL || errno ==   ENODEV # ifdef ENOSYS         ||/
     /|= O_BINARY;     }   else if (   quote)     {       /* If they want/
     /}     } }  int main (int argc,   char **argv) {   /* Optimal size/
     /}   }        else if (ch == '\   t' && output_tabs)   *bpout++ = '\/
     /}  #if O_BINARY   /* We always   read and write in BINARY mode,/
     /}  int main (int argc, char **   argv) {   /* Optimal size of i/o/
     /} #endif    /* Check if any of   the input files are the same as/
     /},     {GETOPT_VERSION_OPTION_   DECL},     {NULL, 0, NULL, 0}   };/
     /++options;    output_tabs = 0;   break;   case_GETOPT_HELP_CHAR;/
     /++options;    output_tabs = 0;   quote = 1;    break;   case 'u':/
     /+= outsize;   }        while (   bpout - wp >= outsize);         /*/
     /< 0)   {     /* Ultrix returns   EOPNOTSUPP on NFS;        HP-UX/
     /< 0)  {    error (0, errno, "%   s", infile);    exit_status = 1;/
     /< 0)  {    error (0, errno, "%   s", infile);    exit_status = 1;/
     /< 0)  {    error (0, errno, "%   s", infile);    exit_status = 1;/
     /= 'M';         *bpout++ = '-';   if (ch >= 128 + 32)    {      if (/
     /= 0;   int mark_line_ends = 0;   int quote = 0;   int output_tabs =/
     /= 1;       SET_BINARY (STDOUT_   FILENO);       /* When stdout is/
     /= 1;     newlines2 = newlines;   return;   }        if (n_read == 0/
     /= 1;    break; #endif   case '   E':    ++options;    mark_line_/
     /= getopt_long (argc, argv, #if   O_BINARY       "benstuvABET" #else/
     /= line_buf + LINE_COUNTER_BUF_   LEN - 3;  /* Position of the last/
     /= line_buf + LINE_COUNTER_BUF_   LEN - 3;  /* Preserves the `cat'/
     /= line_buf + LINE_COUNTER_BUF_   LEN - 8;  /* Position of the first/
     /= xmalloc (insize + 1);     /*   Why are (OUTSIZE - 1 + INSIZE * 4/
     /== 0) #endif   {     size_t n_   write = bpout - outbuf;      if (/
     /== EINVAL || errno == ENODEV #   ifdef ENOSYS         || errno ==/
     /0 && numbers)  {    next_line_   num ();    bpout = stpcpy (bpout,/
     /0)   {     error (0, errno, "%   s", infile);     exit_status = 1;/
     /0, _("%s: input file is output   file"), infile);    exit_status =/
     /0;    break;   case 'e':    ++   options;    mark_line_ends = 1;/
     /1 + INSIZE * 4 + LINE_COUNTER_   BUF_LEN)       bytes allocated for/
     /1 + insize * 4 + LINE_COUNTER_   BUF_LEN);     cat (inbuf, insize,/
     /1;    break;   case 'A':    ++   options;    quote = 1;    mark_/
     /1;    break;   case 'n':    ++   options;    numbers = 1;    break;/
     /1;    break;   case 's':    ++   options;    squeeze_empty_lines =/
     /1000y */ #define LINE_COUNTER_   BUF_LEN 20 static char line_buf[/
     /a       newline, a line number   may be written (according to the/
     /about to wait,    so write all   buffered output before waiting.
     /and -E would surprise users on   DOS/Windows where a line      with/
     /and no newlines appear in this   block of input, we       will have/
     /appear in this block of input,   we       will have at most (/
     /are about to wait,    so write   all buffered output before waiting/
     /are initialized so that BPIN >   EOB, and thereby input      is/
     /argind;    /* Device number of   the output (file or whatever).
     /associated with)   stdout, and   skip this input file if they/
     /AUTHORS N_ ("Torbjorn Granlund   and Richard M. Stallman")  /*/
     /below continue until a newline   character is found,   which means/
     /bpout - outbuf;      if (full_   write (STDOUT_FILENO, outbuf, n_/
     /buffer, to make    an explicit   test for buffer end unnecessary.
     /by single ditto (-s), and this   was the second empty     line?
     /byte in the input buffer, i.e.   the      current end of the buffer/
     /case_GETOPT_HELP_CHAR;   case_   GETOPT_VERSION_CHAR (PROGRAM_NAME,/
     /Cat the file behind INPUT_DESC   to the file behind OUTPUT_DESC.
     /cat, otherwise call simple_cat   to do the actual work. */   int/
     /ch = *bpin++;  }       while (   ch == '\n');        /* Are we at/
     /character is always put at the   end of the buffer, to make    an/
     /characters do, and no newlines   appear in this block of input, we/
     /continue;    }       }      /*   Are line numbers to be written at/
     /copy of the GNU General Public   License    along with this program/
     /counter may overflow within an   hour on a P2/466,    an 18 digit/
     /counter needs about 1000y */ #   define LINE_COUNTER_BUF_LEN 20/
     /digit counter needs about 1000   y */ #define LINE_COUNTER_BUF_LEN/
     /do  {    /* Write if there are   at least OUTSIZE bytes in OUTBUF.
     /done for those types,      and   to allow things like cat < /dev//
     /else       {         error (0,   errno, _("cannot do ioctl on `%s'"/
     /else  {    input_desc = open (   infile, file_open_mode);    if (/
     /eob = inbuf;   bpin = eob + 1;   bpout = outbuf;    for (;;)     {/
     /equivalent to -vET\n\   -b, --   number-nonblank    number nonblank/
     /errno, "%s", infile);    exit_   status = 1;    return;  }        //
     /errno, "%s", infile);    exit_   status = 1;  }     }   while (++/
     /error (0, 0, _("%s: input file   is output file"), infile);    exit/
     /exit_status = 0;  void usage (   int status) {   if (status != 0)/
     /file should not be the same as   any input file. */ #ifndef _WIN32/
     /FILE(s), or standard input, to   standard output.\n\ \n\   -A, --/
     /file_open_mode = O_RDONLY;  /*   If nonzero, call cat, otherwise/
     /file_open_mode);    if (input_   desc < 0)      {        error (0,/
     /for      one of these options,   they don't care much about the/
     /Foundation,    Inc., 59 Temple   Place - Suite 330, Boston, MA 0211/
     /fprintf (stderr, _("Try `%s --   help' for more information.\n"),/
     /fputs (_("\ \n\   -B, --binary   use binary writes to the console/
     /from the Unix cat:    * Always   unbuffered, -u is ignored.
     /goto contin;  }       insize =   ST_BLKSIZE (stat_buf);        /*/
     /have_read_stdin = 0;    struct   stat stat_buf;    /* Variables/
     /if (full_write (STDOUT_FILENO,   buf, n_read) != n_read)  error (/
     /if (line_num_start < line_num_   print)     line_num_print--; }  /*/
     /if (n_to_read == 0) #endif   {   size_t n_write = bpout - outbuf;/
     /if (tty_in)       __djgpp_set_   ctrl_c (1); # endif   }      } #/
     /If stdin is a terminal device,   and it is the ONLY    input file (/
     /inbuf pointers are initialized   so that BPIN > EOB, and thereby/
     /INSIZE * 4 + LINE_COUNTER_BUF_   LEN)       bytes allocated for the/
     /int numbers,      int numbers_   at_empty_lines,      int mark_line/
     /ioctl (input_desc, FIONREAD, &   n_to_read) < 0)   {     /* Ultrix/
     /it is the ONLY    input file (   i.e. we didn't write anything to/
     /License as published by    the   Free Software Foundation; either/
     /LINE_COUNTER_BUF_LEN 20 static   char line_buf[LINE_COUNTER_BUF_LEN/
     /lines to be substituted     by   single ditto (-s), and this was/
     /lines\n\   -s, --squeeze-blank   never more than one single blank/
     /M. Stallman")  /* Undefine, to   avoid warning about redefinition/
     /mark_line_ends = 1;    output_   tabs = 0;    break;  #if O_BINARY/
     /may overflow within an hour on   a P2/466,    an 18 digit counter/
     /means that the buffer is empty   or that a proper newline   has/
     /mode, so that LF causes   both   CR and LF on output, and the/
     /number all output lines\n\   -   s, --squeeze-blank      never more/
     /numbers = 0;   int numbers_at_   empty_lines = 1;   int squeeze_/
     /O_BINARY       "benstuvABET" #   else       "benstuvAET" #endif/
     /O_RDONLY;  /* If nonzero, call   cat, otherwise call simple_cat to/
     /of each line\n\   -n, --number   number all output lines\n\   -s, -/
     /of empty lines or      marking   lines' ends: then we use text I/O,/
     /of the (output file associated   with)   stdout, and skip this/
     /options) as the first thing in   the output buffer. (Done after the/
     /or standard input, to standard   output.\n\ \n\   -A, --show-all/
     /out_ino = 0; #endif     }  #if   O_BINARY   /* We always read and/
     /output buffer. (Done after the   new input is read, but before/
     /output_tabs, numbers, numbers_   at_empty_lines, mark_line_ends,/
     /outsize);    inbuf = xmalloc (   insize);     simple_cat (inbuf,/
     /P2/466,    an 18 digit counter   needs about 1000y */ #define LINE_/
     /pipes returns S_IFSOCK on some   systems, S_IFIFO      on others,/
     /Pointer to the first non-valid   byte in the input buffer, i.e. the/
     /preceding block of input was a   newline, a line number may be/
     /printf (_("\nReport bugs to <%   s>.\n"), PACKAGE_BUGREPORT);     }/
     /Public License as published by   the Free Software Foundation;/
     /read and write in BINARY mode,   since this is the      best way to/
     /S_IFIFO      on others, so the   checking should not be done for/
     /seldom more than LINE_COUNTER_   BUF_LEN       positions.
     /should have received a copy of   the GNU General Public License/
     /simple_cat (inbuf, insize);  }   else  {    inbuf = xmalloc (insize/
     /software; you can redistribute   it and/or modify    it under the/
     /squeeze_empty_lines = 0;   int   mark_line_ends = 0;   int quote =/
     /standard input. */   int have_   read_stdin = 0;    struct stat/
     /stat stat_buf;    /* Variables   that are set according to the/
     /stat_buf;    /* Variables that   are set according to the specified/
     /stdout is in binary mode, make   sure all input files are   also/
     /stdout);       fputs (_("\   -   t                       equivalent/
     /stdout);       fputs (_("\ \n\   With no FILE, or when FILE is -,/
     /switches the console device to   raw I/O, which also affects stdout/
     /terminal device, and it is the   ONLY    input file (i.e. we didn't/
     /that it will be useful,    but   WITHOUT ANY WARRANTY; without even/
     /the console device to   raw I/   O, which also affects stdout to/
     /the end of the buffer, to make   an explicit test for buffer end/
     /the GNU General Public License   along with this program; if not,/
     /the input       buffer empties   or when a newline appears in the/
     /the non-printables, let's show   them   those CR characters as well/
     /the output buffer. (Done after   the       new input is read, but/
     /these options, they don't care   much about the original      file/
     /they don't care much about the   original      file contents anyway/
     /things like cat < /dev/tty > /   dev/tty, checking      is not done/
     /this program; if not, write to   the Free Software Foundation,/
     /those types,      and to allow   things like cat < /dev/tty > /dev//
     /to be written is done when the   input       buffer empties or when/
     /to binary switches the console   device to   raw I/O, which also/
     /to standard output.\n\ \n\   -   A, --show-all           equivalent/
     /to the first non-valid byte in   the input buffer, i.e. the/
     /to the given       options) as   the first thing in the output/
     /to the position where the next   character shall be written.
     /Update the pointers and insert   a sentinel at the buffer    end.
     /use_fionread = 1; #endif    /*   The inbuf pointers are initialized/
     /Usually much faster than other   versions of cat, the difference/
     /warranty of    MERCHANTABILITY   or FITNESS FOR A PARTICULAR/
     /we at the beginning of a line,   and line numbers are requested?
     /which version of `cat' to use.   If any options (more than -u,   --/
     /will be useful,    but WITHOUT   ANY WARRANTY; without even the/
     /Windows where a line      with   only CR-LF is an empty line.    /DOS
     /written is done when the input   buffer empties or when a newline/
     /you can redistribute it and/or   modify    it under the terms of/
     :    * Always unbuffered, -u is   ignored.          /from the Unix cat
     :    ++options;    numbers = 1;   numbers_at_empty_lines = 0;/    /'b'
     ;         /* Is there any input   to read immediately?    /to_read = 0
     ;         /* Move the remaining   bytes to the beginning of the/    /)
     ;       fputs (_("\ \n\ With no   FILE, or when FILE is -, read/    /)
     ;       fputs (_("\ Concatenate   FILE(s), or standard input, to/   /)
     ;      }  }     } }  int main (   int argc, char **argv) {   /*/   /++
     ;     break;   }         ch = *   bpin++;      }  }     } }  int/   /1
     ;    int c;    /* Index in argv   to processed argument.      /*outbuf
     ;   /* Input file can be output   file for non-regular files.    /buf)
     ;  /* Descriptor on which input   file is open.          /char *infile
     ; # ifdef __DJGPP__     /* This   is DJGPP-specific.     /(input_desc)
     ;;)     {       /* Read a block   of input.                */    for (
     \ Usage: %s [OPTION] [FILE]...\   n\ "),        program_name);/   /_("
     \0'   };  /* Position in `line_   buf' where printing starts.    /', '
     __DJGPP__     /* This is DJGPP-   specific.           /_desc); # ifdef
     _BUF_LEN)       bytes allocated   for the output buffer?     /_COUNTER
     _dev;       out_ino = stat_buf.   st_ino;     }   else     {/     /.st
     _LEN)       bytes allocated for   the output buffer?     /_COUNTER_BUF
     _output)      {        int tty_   in = isatty (input_desc);/   /binary
     _print);       }   }         /*   Output a currency symbol if/   /_num
     _read == 0)   {     newlines2 =   newlines;     return;   }/    /if (n
     _read;    /* Loop until the end   of the file.          */   ssize_t n
     _t n_read;    /* Loop until the   end of the file.          */   ssize
     _t out_dev;    /* I-node number   of the output.              */   dev
     `cat', otherwise use   `simple_   cat'.                /specified, use
     {   /* Last character read from   the input buffer.     /_empty_lines)
     {"number", no_argument, NULL, '   n'},     {"squeeze-blank", no_/   /,
     || binary_files)     {       /*   Switch stdout to BINARY mode.    /))
     ++ = '$';         /* Output the   newline.            /_ends)   *bpout
     < /dev/tty > /dev/tty, checking   is not done for device files/   /cat
     < line_num_print)     line_num_   print--; }  /* Plain cat.    /_start
     = ch + 64;   }        else if (   ch != '\n')   *bpout++ = ch;/    /++
     0 newlines makes NEWLINES -1, 1   newline makes NEWLINES 1,      etc/
     0)  {    error (0, errno, "%s",   infile);    exit_status = 1;/     /<
     0)  {    error (0, errno, "%s",   infile);    exit_status = 1;/   /) <
     0)  break;        /* Write this   block out.            /if (n_read ==
     0;  /* Count of non-fatal error   conditions.         /int newlines2 =
     1';   else     *line_buf = '>';   if (line_num_start < line_num_/   /'
     6,    an 18 digit counter needs   about 1000y */ #define LINE_/   //46
     90, 91, 1995-2002 Free Software   Foundation, Inc.            /(C) 88,
     all input files are   also read   in binary mode.     /mode, make sure
     an explicit test for buffer end   unnecessary.              /, to make
     and M- notation, except for LFD   and TAB\n\ "), stdout);/      /use ^
     argv) {   /* Optimal size of i/   o operations of output.     /char **
     at end of each line\n\   -n, --   number             number all/    /$
     at the beginning of a line, and   line numbers are requested?      /we
     BINARY   int binary_files  = 0;   int binary_output = 0; #endif/   /O_
     BINARY (input_desc); # ifdef __   DJGPP__     /* This is DJGPP-/    /_
     But keep console output in text   mode, so that LF causes   both CR/
     cat:    * Always unbuffered, -u   is ignored.           /from the Unix
     char *infile;  /* Descriptor on   which input file is open.    /static
     char *program_name;  /* Name of   input file.                       */
     characters as well, so make the   input binary.       /them   those CR
     consecutive newlines there have   been in the      input.    /how many
     currency symbol if requested (-   e).                     //* Output a
     desc = open (infile, file_open_   mode);    if (input_desc < 0)/    /_
     DESC to the file behind OUTPUT_   DESC.            /file behind INPUT_
     desc);         /* If stdin is a   terminal device, and it is the/   /_
     desc); # ifdef __DJGPP__     /*   This is DJGPP-specific.     /(input_
     dev;    /* I-node number of the   output.              */   dev_t out_
     e. have two or more consecutive   newlines been read?)             (i.
     endif       printf (_("\nReport   bugs to <%s>.\n"), PACKAGE_/   /); #
     endif   case 'E':    ++options;   mark_line_ends = 1;    break;/    /#
     endp = line_num_end;   do     {   if ((*endp)++ < '9')  return;/    /*
     EOPNOTSUPP on NFS;        HP-UX   returns ENOTTY on pipes.    /returns
     errno, "%s", infile);     exit_   status = 1;     newlines2 =/    /(0,
     error (0, errno, "%s", infile);   exit_status = 1;    return;  }/   /{
     FILE]...\n\ "),        program_   name);       fputs (_("\/       /] [
     files and print on the standard   output.              /-- concatenate
     files are   also read in binary   mode.                /sure all input
     fputs (HELP_OPTION_DESCRIPTION,   stdout);       fputs (VERSION_/   /;
     fstat on pipes returns S_IFSOCK   on some systems, S_IFIFO      on/
     General Public License for more   details.              See the    GNU
     if (n_read < 0)  {    error (0,   errno, "%s", infile);    exit_/   /;
     If all       characters do, and   no newlines appear in this block/
     ifdef FIONREAD   /* If nonzero,   use the FIONREAD ioctl, as an/    /#
     inbuf, insize, outbuf, outsize,   quote,         output_tabs,/      /(
     include <sys/ioctl.h> #endif  #   include "system.h" #include "/    /#
     infile;  /* Descriptor on which   input file is open.          /char *
     Initially 0 to indicate that we   are at the beginning of a      new/
     input files are the same as the   output file.          /if any of the
     input, to standard output.\n\ \   n\   -A, --show-all/    /or standard
     input_desc;  /* Buffer for line   numbers.               */ static int
     insert a sentinel at the buffer   end.                   /pointers and
     insize = max (insize, outsize);   inbuf = xmalloc (insize);/    /0)  {
     int outsize;    /* Optimal size   of i/o operations of input.       */
     ISREG (stat_buf.st_mode))     {   out_dev = stat_buf.st_dev;/     /(S_
     LF on output, and the output is   readable.               /both CR and
     line      with only CR-LF is an   empty line.        //Windows where a
     many consecutive newlines there   have been in the      input.    /how
     most (OUTSIZE - 1 + INSIZE * 4)   bytes in the buffer.        /have at
     Move the remaining bytes to the   beginning of the    buffer.      //*
     n\   -u                       (   ignored)\n\   -v, --show-/   /as ^I\
     newlines there have been in the   input.                  /consecutive
     Not quoting, neither of -v, -e,   or -t specified.      /else  {    /*
     Number of characters written by   each write call.         /,       /*
     O, which also affects stdout to   console.         /device to   raw I/
     of a line, and line numbers are   requested?         /at the beginning
     of characters read in each read   call.             /,       /* Number
     of the input files are the same   as the output file.    /Check if any
     official name of this program (   e.g., no `g' prefix).    /"   /* The
     one of -v, -e, or -t specified,   scan for chars that need/     /least
     out_dev;    /* I-node number of   the output.               */   dev_t
     output_tabs)   *bpout++ = '\t';   else if (ch == '\n')   {/   /'\t' &&
     OUTSIZE - 1 + INSIZE * 4) bytes   in the buffer.       /have at most (
     Pointer to the beginning of the   input buffer.         /cat (      /*
     Pointer to the beginning of the   output buffer.     /insize,       /*
     Position of the last digit in `   line_buf'.        /_BUF_LEN - 3;  /*
     program_name;  /* Name of input   file.                      */ char *
     read == 0) #endif   {     size_   t n_write = bpout - outbuf;/   /_to_
     return;       }   }        if (   n_to_read == 0) #endif   {/       /;
     returns ENODEV on special files   like /dev/null.            /More/BSD
     s: input file is output file"),   infile);    exit_status = 1;/   /("%
     since this is the      best way   to copy the files verbatim.       /,
     single ditto (-s), and this was   the second empty     line?       /by
     special files        like /dev/   null.             /returns ENODEV on
     specified, use `cat', otherwise   use   `simple_cat'.    /--help) were
     style text    file, like people   expect.            /" creates a DOS-
     sure all input files are   also   read in binary mode.     /mode, make
     T, --show-tabs          display   TAB characters as ^I\n\   -u/     /-
     test whether output needs to be   written is done when the input/    A
     that LF causes   both CR and LF   on output, and the output is/    /so
     that we are at the beginning of   a      new line.      /0 to indicate
     The "state" of the procedure is   determined by      NEWLINES.
     the file behind `input_desc' to   STDOUT_FILENO.                Copies
     the first non-valid byte in the   input buffer, i.e. the/          /to
     the input files are the same as   the output file.    /Check if any of
     the next character in the input   buffer.               //* Pointer to
     the ONLY    input file (i.e. we   didn't write anything to the/    /is
     the original      file contents   anyway).          /t care much about
     those CR characters as well, so   make the input binary.    /show them
     to be written at empty lines (-   n)?              /* Are line numbers
     to make    an explicit test for   buffer end unnecessary.     /buffer,
     to_read) < 0)   {     /* Ultrix   returns EOPNOTSUPP on NFS;/   /, &n_
     want to see the non-printables,   let's show them   those CR/    /they
     we didn't write anything to the   output yet), switch the output/   /.
     where a line      with only CR-   LF is an empty line.    /DOS/Windows
     while (endp >= line_num_start);   if (line_num_start > line_buf)/   /}
     wp >= outsize);         /* Move   the remaining bytes to the/       /-
     wp, bpout - wp);        bpout =   outbuf + (bpout - wp);      }/    /,
     xyzzy" creates a DOS-style text   file, like people expect.    /"cat >
     yet), switch the output back to   TEXT mode.         /to the    output
     You should have received a copy   of the GNU General Public License/
    /' ', ' ', ' ', ' ', '0',     '\   t', '\0'   };  /* Position in `/
    /';     }   while (endp >= line_   num_start);   if (line_num_start >/
    /';   if (line_num_start < line_   num_print)     line_num_print--; }/
    /'\t' && !output_tabs)   {     *   bpout++ = '^';     *bpout++ = ch +/
    /'},     {"number", no_argument,   NULL, 'n'},     {"squeeze-blank",/
    /'}, #if O_BINARY     {"binary",   no_argument, NULL, 'B'}, #endif/
    /'n'},     {"squeeze-blank", no_   argument, NULL, 's'},     {"show-/
    /--binary             use binary   writes to the console device.\n\n\/
    /--number             number all   output lines\n\   -s, --squeeze-/
    /--show-all           equivalent   to -vET\n\   -b, --number-nonblank/
    /--squeeze-blank      never more   than one single blank line\n\ "),/
    /- = '0';     }   while (endp >=   line_num_start);   if (line_num_/
    /- outbuf;      if (full_write (   STDOUT_FILENO, outbuf, n_write) !=/
    /-blank      never more than one   single blank line\n\ "), stdout);/
    /-E would surprise users on DOS/   Windows where a line      with/
    /-ends          display $ at end   of each line\n\   -n, --number/
    /-read.h"   /* The official name   of this program (e.g., no `g'/
    /-v, -e, or -t specified,   scan   for chars that need conversion.
    /-vET\n\   -b, --number-nonblank   number nonblank output lines\n\/
    /!STREQ (infile, "-") && close (   input_desc) < 0)  {    error (0,/
    /" #include "error.h" #include "   full-write.h" #include "safe-read./
    /"");   bindtextdomain (PACKAGE,   LOCALEDIR);   textdomain (PACKAGE)/
    /");    exit (exit_status == 0 ?   EXIT_SUCCESS : EXIT_FAILURE); }
    /", infile);    exit_status = 1;   goto contin;  }       insize = ST_/
    /", infile);    exit_status = 1;   return;  }        /* End of this/
    /"error.h" #include "full-write.   h" #include "safe-read.h"   /* The/
    /"safe-read.h"   /* The official   name of this program (e.g., no `g'/
    /#define LINE_COUNTER_BUF_LEN 20   static char line_buf[LINE_COUNTER_/
    /#define max(h,i) ((h) > (i) ? (   h) : (i))  /* Name under which/
    /#endif     {GETOPT_HELP_OPTION_   DECL},     {GETOPT_VERSION_OPTION_/
    /#endif     }  #if O_BINARY   /*   We always read and write in BINARY/
    /#endif    /* Nonzero if we have   ever read standard input. */   int/
    /#endif    /* The inbuf pointers   are initialized so that BPIN > EOB/
    /#if O_BINARY     {"binary", no_   argument, NULL, 'B'}, #endif     {/
    /#include "safe-read.h"   /* The   official name of this program (e.g/
    /& stat_buf.st_dev == out_dev &&   stat_buf.st_ino == out_ino    && (/
    /&& output_tabs)   *bpout++ = '\   t';        else if (ch == '\n')/
    /(;;)      {        if (ch == '\   t' && !output_tabs)   {     *bpout/
    /(_("\ \n\ With no FILE, or when   FILE is -, read standard input.\n\/
    /(_("\nReport bugs to <%s>.\n"),   PACKAGE_BUGREPORT);     }   exit (/
    /(++argind < argc);    if (have_   read_stdin && close (0) < 0)/
    /(0);        /* Setting stdin to   binary switches the console device/
    /(argind < argc)  infile = argv[   argind];        if (infile[0] == '/
    /(c = getopt_long (argc, argv, #   if O_BINARY       "benstuvABET" #/
    /(ch == '\t' && output_tabs)   *   bpout++ = '\t';        else if (ch/
    /(ch >= 128 + 32)    {      if (   ch < 128 + 127)        *bpout++ =/
    /(Done after the       new input   is read, but before processing of/
    /(full_write (STDOUT_FILENO, wp,   outsize) != outsize)       error (/
    /(i) ? (h) : (i))  /* Name under   which this program was invoked.
    /(input_desc, &stat_buf) < 0)  {   error (0, errno, "%s", infile);/
    /(stat_buf);   /* Input file can   be output file for non-regular/
    /(STDOUT_FILENO, &stat_buf) < 0)   error (EXIT_FAILURE, errno, _("/
    /(STDOUT_FILENO, buf, n_read) !=   n_read)  error (EXIT_FAILURE,/
    /(STDOUT_FILENO, wp, outsize) !=   outsize)       error (EXIT_FAILURE/
    /)       *bpout++ = ch;     else   if (ch == 127)       {         */
    /)   {     *bpout++ = '^';     *   bpout++ = ch + 64;   }        else/
    /)   {     if (ch < 127)       *   bpout++ = ch;     else if (ch == 1/
    /)   {     newlines2 = newlines;   return;   }         /* Update the/
    /) && close (input_desc) < 0)  {   error (0, errno, "%s", infile);/
    /) < 0)     error (EXIT_FAILURE,   errno, "-");    exit (exit_status/
    /) < 0)     error (EXIT_FAILURE,   errno, _("standard output"));/
    /), infile);    exit_status = 1;   goto contin;  }        /* Select/
    /);        /* Compare the device   and i-node numbers of this input/
    /);       fputs (VERSION_OPTION_   DESCRIPTION, stdout);       fputs/
    /);    exit_status = 1;  }     }   while (++argind < argc);    if (/
    /);    inbuf = xmalloc (insize);   simple_cat (inbuf, insize);  }/
    /);   if (line_num_start > line_   buf)     *--line_num_start = '1';/
    /* Compare the device and i-node   numbers of this input file with/
    /* If quoting, i.e. at least one   of -v, -e, or -t specified,   scan/
    /* Select which version of `cat'   to use. If any options (more than/
    /*/    if (S_ISREG (stat_buf.st_   mode))     {       out_dev = stat_/
    /*/   int options = 0;    static   struct option const long_options[]/
    /*bpin++;      }  }     } }  int   main (int argc, char **argv) {   //
    /*bpout++ = '^';      *bpout++ =   ch - 128 + 64;    }       }   }/
    /,         output_tabs, numbers,   numbers_at_empty_lines, mark_line_/
    /,         squeeze_empty_lines);   free (outbuf);  }        free (/
    /,       /* Number of characters   preferably read or written by each/
    /,       /* Number of characters   written by each write call.
    /,     {"show-all", no_argument,   NULL, 'A'}, #if O_BINARY     {"/
    /,   which means that the buffer   is empty or that a proper newline/
    /, _("cannot do ioctl on `%s'"),   infile);         exit_status = 1;/
    /, because otherwise      -b, -s   and -E would surprise users on DOS/
    /, checking      is not done for   device files either. */    if (S_/
    /, errno, _("standard output"));   outsize = ST_BLKSIZE (stat_buf);/
    /, except for LFD and TAB\n\ "),   stdout);       fputs (HELP_OPTION_/
    /, inbuf, insize);        if (n_   read < 0)   {     error (0, errno,/
    /, infile);     exit_status = 1;   newlines2 = newlines;     return;/
    /, line_num_print);  }        /*   Here CH cannot contain a newline/
    /, NULL, 'E'},     {"show-tabs",   no_argument, NULL, 'T'},     {"/
    /, NULL, 'v'},     {"show-ends",   no_argument, NULL, 'E'},     {"/
    /, numbers_at_empty_lines, mark_   line_ends,         squeeze_empty_/
    /, so the checking should not be   done for those types,      and to/
    /,i) ((h) > (i) ? (h) : (i))  /*   Name under which this program was/
    /. */   int have_read_stdin = 0;   struct stat stat_buf;    /*/
    /. at least one of -v, -e, or -t   specified,   scan for chars that/
    /..\n\ "),        program_name);   fputs (_("\ Concatenate FILE(s),/
    /.h" #include "safe-read.h"   /*   The official name of this program/
    /.se, Torbjorn Granlund, advised   by rms, Richard Stallman. */  #/
    /.st_dev == out_dev && stat_buf.   st_ino == out_ino    && (input_/
    //  /* Differences from the Unix   cat:    * Always unbuffered, -u is/
    // #ifndef _WIN32     int check_   redirection = 1; #else   int check/
    // static char *line_num_print =   line_buf + LINE_COUNTER_BUF_LEN -/
    // static char *line_num_start =   line_buf + LINE_COUNTER_BUF_LEN -/
    //* If nonzero, use the FIONREAD   ioctl, as an optimization.
    //* Nonzero if we have ever read   standard input. */   int have_read/
    //* Ultrix returns EOPNOTSUPP on   NFS;        HP-UX returns ENOTTY/
    //tty, checking      is not done   for device files either. */    if/
    /:    ++options;    numbers = 1;   break;   case 's':    ++options;/
    /: then we use text I/O, because   otherwise      -b, -s and -E would/
    /;         newlines2 = newlines;   return;       }   }        if (n_/
    /;       }   }         /* Output   a currency symbol if requested (-e/
    /;      }  }       else  {    /*   Not quoting, neither of -v, -e, or/
    /;      else        {          *   bpout++ = '^';          *bpout++ =/
    /;     /* Why are (OUTSIZE - 1 +   INSIZE * 4 + LINE_COUNTER_BUF_LEN)/
    /;     return;   }        if (n_   read == 0)   {     newlines2 =/
    /;    /* Pointer to the position   where the next character shall be/
    /;    }       }      /* Are line   numbers to be written at empty/
    /;    break;   case_GETOPT_HELP_   CHAR;   case_GETOPT_VERSION_CHAR (/
    /;    if (input_desc < 0)      {   error (0, errno, "%s", infile);/
    /;    output_tabs = 0;    break;   case_GETOPT_HELP_CHAR;   case_/
    /;    static struct option const   long_options[] =   {     {"number-/
    /;   int output_tabs = 1; #if O_   BINARY   int binary_files  = 0;/
    /;  }     }    /* Get device, i-   node number, and optimal blocksize/
    /; #endif   int file_open_mode =   O_RDONLY;  /* If nonzero, call cat/
    /; either version 2, or (at your   option)    any later version.
    /\n';      }    ch = *bpin++;  }   while (ch == '\n');        /* Are/
    /\n"), PACKAGE_BUGREPORT);     }   exit (status == 0 ? EXIT_SUCCESS :/
    /] =   {     {"number-nonblank",   no_argument, NULL, 'b'},     {"/
    /^';     *bpout++ = ch + 64;   }   ch = *bpin++;      }  }       else/
    /^';     *bpout++ = ch + 64;   }   else if (ch != '\n')   *bpout++ =/
    /_at_empty_lines,      int mark_   line_ends,      int squeeze_empty_/
    /_BINARY   /* We always read and   write in BINARY mode, since this/
    /_BLKSIZE (stat_buf);   /* Input   file can be output file for non-/
    /_buf.st_dev == out_dev && stat_   buf.st_ino == out_ino    && (input/
    /_buf.st_ino;     }   else     {   check_redirection = 0; #ifdef lint/
    /_buf.st_mode))     {       out_   dev = stat_buf.st_dev;       out_/
    /_COUNTER_BUF_LEN 20 static char   line_buf[LINE_COUNTER_BUF_LEN] =/
    /_dev && stat_buf.st_ino == out_   ino    && (input_desc != STDIN_/
    /_dev == out_dev && stat_buf.st_   ino == out_ino    && (input_desc !/
    /_end = line_buf + LINE_COUNTER_   BUF_LEN - 3;  /* Preserves the `/
    /_FILENO)        && !(numbers ||   squeeze_empty_lines || mark_line_/
    /_FILENO, outbuf, n_write) != n_   write)       error (EXIT_FAILURE,/
    /_fionread = 0;     else       {   error (0, errno, _("cannot do/
    /_fionread = 1; #endif    /* The   inbuf pointers are initialized so/
    /_lines)    {      ch = *bpin++;   continue;    }       }      /* Are/
    /_mode |= O_BINARY;     }   else   if (quote)     {       /* If they/
    /_output = 0; #endif   int file_   open_mode = O_RDONLY;  /* If/
    /_output = 1;       SET_BINARY (   STDOUT_FILENO);       /* When/
    /_read) != n_read)  error (EXIT_   FAILURE, errno, _("write error"));/
    /_read_stdin = 0;    struct stat   stat_buf;    /* Variables that are/
    /_redirection    && stat_buf.st_   dev == out_dev && stat_buf.st_ino/
    /_start = '1';   else     *line_   buf = '>';   if (line_num_start </
    /_start > line_buf)     *--line_   num_start = '1';   else     *line_/
    /_start);   if (line_num_start >   line_buf)     *--line_num_start =/
    /_status = 1;    goto contin;  }   insize = ST_BLKSIZE (stat_buf);/
    /_SUCCESS : EXIT_FAILURE); }  /*   Compute the next line number.
    /_t n_read;    /* Determines how   many consecutive newlines there/
    /{        error (0, errno, "%s",   infile);        exit_status = 1;/
    /{    input_desc = open (infile,   file_open_mode);    if (input_desc/
    /{ #ifdef FIONREAD        int n_   to_read = 0;         /* Is there/
    /{"binary", no_argument, NULL, '   B'}, #endif     {GETOPT_HELP_/
    /|| squeeze_empty_lines || mark_   line_ends))       || binary_files)/
    /}        else if (ch == '\t' &&   output_tabs)   *bpout++ = '\t';/
    /}       else  {    input_desc =   open (infile, file_open_mode);/
    /}    }         else    {      *   bpout++ = '^';      *bpout++ = ch/
    /},     {"show-nonprinting", no_   argument, NULL, 'v'},     {"show-/
    /+ = ch + 64;   }         ch = *   bpin++;      }  }       else  {/
    /+ LINE_COUNTER_BUF_LEN - 3;  /*   Position of the last digit in `/
    /+ LINE_COUNTER_BUF_LEN - 3;  /*   Preserves the `cat' function's/
    /+ LINE_COUNTER_BUF_LEN - 8;  /*   Position of the first digit in `/
    /++options;    binary_files = 1;   break; #endif   case 'E':    ++/
    /< argc)  infile = argv[argind];   if (infile[0] == '-' && infile[1]/
    /<getopt.h> #include <sys/types.   h> #ifndef _POSIX_SOURCE # include/
    /<stdio.h> #include <getopt.h> #   include <sys/types.h> #ifndef _/
    /= -1)     {       switch (c)  {   case 0:    break;   case 'b':    +/
    /= 0)  {    have_read_stdin = 1;   input_desc = 0;  #if O_BINARY    //
    /= 0;   int binary_output = 0; #   endif   int file_open_mode = O_/
    /= 0;   int output_tabs = 1; #if   O_BINARY   int binary_files  = 0;/
    /= 0;  #if O_BINARY    /* Switch   stdin to BINARY mode if needed.
    /= 0;  void usage (int status) {   if (status != 0)     fprintf (/
    /= 0; #endif    /* Nonzero if we   have ever read standard input. *//
    /= 0; #ifdef lint  /* Suppress `   used before initialized' warning.
    /= 1;        continue;      }  }   if (fstat (input_desc, &stat_buf)/
    /= 1;    input_desc = 0;  #if O_   BINARY    /* Switch stdin to/
    /= 1; #if O_BINARY   int binary_   files  = 0;   int binary_output =/
    /= inbuf;        eob = bpin + n_   read;        *eob = '\n';      }/
    /= n_read)  error (EXIT_FAILURE,   errno, _("write error"));     } }/
    /= out_dev && stat_buf.st_ino ==   out_ino    && (input_desc != STDIN/
    /= outsize)      {        char *   wp = outbuf;        do   {     if/
    /= outsize);         /* Move the   remaining bytes to the beginning/
    /= safe_read (input_desc, inbuf,   insize);        if (n_read < 0)/
    /= xmalloc (insize);     simple_   cat (inbuf, insize);  }       else/
    /== '\n')   {     newlines = -1;   break;   }        else   {     */
    /== out_ino    && (input_desc !=   STDIN_FILENO))  {    error (0, 0,/
    /> #endif  #include "system.h" #   include "closeout.h" #include "/
    />= line_num_start);   if (line_   num_start > line_buf)     *--line_/
    /0)  {    error (0, errno, "%s",   infile);    exit_status = 1;  }/
    /0] == '-' && infile[1] == 0)  {   have_read_stdin = 1;    input_desc/
    /0y */ #define LINE_COUNTER_BUF_   LEN 20 static char line_buf[LINE_/
    /1;    goto contin;  }        /*   Select which version of `cat' to/
    /1;  }     }   while (++argind <   argc);    if (have_read_stdin &&/
    /27)        *bpout++ = ch - 128;   else        {          *bpout++ =/
    /4;    }       }   }        else   if (ch == '\t' && output_tabs)   */
    /4;   }        else if (ch != '\   n')   *bpout++ = ch;        else/
    /A':    ++options;    quote = 1;   mark_line_ends = 1;    output_tabs/
    /all       characters do, and no   newlines appear in this block of/
    /always read and write in BINARY   mode, since this is the      best/
    /and write in BINARY mode, since   this is the      best way to copy/
    /any options (more than -u,   --   version, or --help) were specified/
    /anything to the    output yet),   switch the output back to TEXT/
    /are (OUTSIZE - 1 + INSIZE * 4 +   LINE_COUNTER_BUF_LEN)       bytes/
    /are when      they request line   numbering, squeezing of empty/
    /argc)   setmode (STDOUT_FILENO,   O_TEXT);        else   {     SET_/
    /as any input file. */ #ifndef _   WIN32     int check_redirection =/
    /at_empty_lines, mark_line_ends,   squeeze_empty_lines);     free (/
    /AUTHORS);   default:    usage (   EXIT_FAILURE);  }     }    /* Get/
    /BINARY  case 'B':    ++options;   binary_files = 1;    break; #endif/
    /binary_output = 0; #endif   int   file_open_mode = O_RDONLY;  /* If/
    /bpin + n_read;        *eob = '\   n';      }    else      {        //
    /break;   case_GETOPT_HELP_CHAR;   case_GETOPT_VERSION_CHAR (PROGRAM_/
    /break; #endif   case 'E':    ++   options;    mark_line_ends = 1;/
    /by rms, Richard Stallman. */  #   include <config.h>  #include </
    /ch - 128 + 64;    }       }   }   else if (ch == '\t' && output_tabs/
    /ch = *bpin++;      }  }     } }   int main (int argc, char **argv) {/
    /char *eob;    /* Pointer to the   position where the next character/
    /char *inbuf,       /* Number of   characters read in each read call.
    /char *line_num_end = line_buf +   LINE_COUNTER_BUF_LEN - 3;  /*/
    /char line_buf[LINE_COUNTER_BUF_   LEN] =   {     ' ', ' ', ' ', ' ',/
    /Check if any of the input files   are the same as the output file.
    /checking should not be done for   those types,      and to allow/
    /close (0) < 0)     error (EXIT_   FAILURE, errno, "-");    exit (/
    /config.h>  #include <stdio.h> #   include <getopt.h> #include <sys//
    /console output in text mode, so   that LF causes   both CR and LF on/
    /continue;      }  }        if (   fstat (input_desc, &stat_buf) < 0)/
    /desc, buf, bufsize);       if (   n_read < 0)  {    error (0, errno,/
    /Determines how many consecutive   newlines there have been in the/
    /device files either. */    if (   S_ISREG (stat_buf.st_mode))     {/
    /device to   raw I/O, which also   affects stdout to console.
    /distributed in the hope that it   will be useful,    but WITHOUT ANY/
    /E':    ++options;    mark_line_   ends = 1;    break;   case 'T':/
    /e':    ++options;    mark_line_   ends = 1;    quote = 1;    break;/
    /e. at least one of -v, -e, or -   t specified,   scan for chars that/
    /else   {     SET_BINARY (input_   desc); # ifdef __DJGPP__     /*/
    /empty_lines = 1;   int squeeze_   empty_lines = 0;   int mark_line_/
    /endif    /* Check if any of the   input files are the same as the/
    /endif   int file_open_mode = O_   RDONLY;  /* If nonzero, call cat,/
    /endp >= line_num_start);   if (   line_num_start > line_buf)     *--/
    /endp)++ < '9')  return;       *   endp-- = '0';     }   while (endp/
    /errno == EOPNOTSUPP || errno ==   ENOTTY         || errno == EINVAL/
    /errno, _("cannot do ioctl on `%   s'"), infile);         exit_status/
    /error (0, errno, "%s", infile);   exit_status = 1;        continue;/
    /error (0, errno, "%s", infile);   exit_status = 1;     newlines2 =/
    /error (0, errno, "%s", infile);   exit_status = 1;    goto contin;/
    /error (0, errno, "%s", infile);   exit_status = 1;  }     }   while/
    /error (EXIT_FAILURE, errno, _("   standard output"));    outsize =/
    /error (EXIT_FAILURE, errno, _("   write error"));     } }  /* Cat/
    /error (EXIT_FAILURE, errno, _("   write error"));     bpout = outbuf/
    /error (EXIT_FAILURE, errno, _("   write error"));     wp += outsize;/
    /FAILURE, errno, "-");    exit (   exit_status == 0 ? EXIT_SUCCESS :/
    /file associated with)   stdout,   and skip this input file if they/
    /file is output file"), infile);   exit_status = 1;    goto contin;/
    /file. */ #ifndef _WIN32     int   check_redirection = 1; #else   int/
    /FILENO, buf, n_read) != n_read)   error (EXIT_FAILURE, errno, _("/
    /for LFD and TAB\n\ "), stdout);   fputs (HELP_OPTION_DESCRIPTION,/
    /free (outbuf);  }        free (   inbuf);      contin:       if (!/
    /full_write (STDOUT_FILENO, buf,   n_read) != n_read)  error (EXIT_/
    /General Public License    along   with this program; if not, write/
    /GETOPT_HELP_OPTION_DECL},     {   GETOPT_VERSION_OPTION_DECL},     {/
    /getopt_long (argc, argv, #if O_   BINARY       "benstuvABET" #else/
    /have received a copy of the GNU   General Public License    along/
    /HELP_OPTION_DECL},     {GETOPT_   VERSION_OPTION_DECL},     {NULL, 0/
    /if (use_fionread     && ioctl (   input_desc, FIONREAD, &n_to_read)/
    /If nonzero, call cat, otherwise   call simple_cat to do the actual/
    /if O_BINARY       fputs (_("\ \   n\   -B, --binary             use/
    /if O_BINARY   /* We always read   and write in BINARY mode, since/
    /ifdef FIONREAD        int n_to_   read = 0;         /* Is there any/
    /IFSOCK on some systems, S_IFIFO   on others, so the checking should/
    /in text mode, so that LF causes   both CR and LF on output, and the/
    /in the preceding block of input   was a       newline, a line number/
    /include "closeout.h" #include "   error.h" #include "full-write.h" #/
    /include <sys/types.h> #ifndef _   POSIX_SOURCE # include <sys/ioctl./
    /initialized so that BPIN > EOB,   and thereby input      is read/
    /ino    && (input_desc != STDIN_   FILENO))  {    error (0, 0, _("%s:/
    /ino_t out_ino;    /* Nonzero if   the output file should not be the/
    /input_desc != STDIN_FILENO))  {   error (0, 0, _("%s: input file is/
    /insize);     simple_cat (inbuf,   insize);  }       else  {    inbuf/
    /insize,       /* Pointer to the   beginning of the output buffer.
    /insize, outbuf, outsize, quote,   output_tabs, numbers, numbers_at_/
    /int argind;    /* Device number   of the output (file or whatever).
    /int insize,       /* Pointer to   the beginning of the output buffer/
    /int newlines2 = 0;  /* Count of   non-fatal error conditions.
    /int numbers = 0;   int numbers_   at_empty_lines = 1;   int squeeze_/
    /int numbers_at_empty_lines = 1;   int squeeze_empty_lines = 0;   int/
    /int outsize,       /* Variables   that have values according to the/
    /int squeeze_empty_lines) {   /*   Last character read from the input/
    /is a terminal device, and it is   the ONLY    input file (i.e. we/
    /is always put at the end of the   buffer, to make    an explicit/
    /is distributed in the hope that   it will be useful,    but WITHOUT/
    /is the ONLY    input file (i.e.   we didn't write anything to the/
    /isatty (input_desc);         /*   If stdin is a terminal device, and/
    /last character in the preceding   block of input was a       newline/
    /LC_ALL, "");   bindtextdomain (   PACKAGE, LOCALEDIR);   textdomain/
    /like cat < /dev/tty > /dev/tty,   checking      is not done for/
    /line_buf = '>';   if (line_num_   start < line_num_print)     line_/
    /line_ends = 0;   int quote = 0;   int output_tabs = 1; #if O_BINARY/
    /line_num_end = line_buf + LINE_   COUNTER_BUF_LEN - 3;  /* Preserves/
    /lines = 1;   int squeeze_empty_   lines = 0;   int mark_line_ends =/
    /lines,      int mark_line_ends,   int squeeze_empty_lines) {   /*/
    /M- notation, except for LFD and   TAB\n\ "), stdout);       fputs (/
    /mode, make sure all input files   are   also read in binary mode.
    /modify    it under the terms of   the GNU General Public License as/
    /much faster than other versions   of cat, the difference    is/
    /n_read = safe_read (input_desc,   buf, bufsize);       if (n_read </
    /n_read = safe_read (input_desc,   inbuf, insize);        if (n_read/
    /newline character is always put   at the end of the buffer, to make/
    /next_line_num (void) {   char *   endp = line_num_end;   do     {/
    /no_argument, NULL, 'A'}, #if O_   BINARY     {"binary", no_argument,/
    /no_argument, NULL, 'b'},     {"   number", no_argument, NULL, 'n'},/
    /no_argument, NULL, 'E'},     {"   show-tabs", no_argument, NULL, 'T'/
    /no_argument, NULL, 'n'},     {"   squeeze-blank", no_argument, NULL,/
    /no_argument, NULL, 's'},     {"   show-nonprinting", no_argument,/
    /no_argument, NULL, 'T'},     {"   show-all", no_argument, NULL, 'A'}/
    /no_argument, NULL, 'v'},     {"   show-ends", no_argument, NULL, 'E'/
    /node numbers of this input file   with   the corresponding values of/
    /non-printables, let's show them   those CR characters as well, so/
    /nonblank", no_argument, NULL, '   b'},     {"number", no_argument,/
    /not change    unless the number   of lines is larger than 999999.
    /not, write to the Free Software   Foundation,    Inc., 59 Temple/
    /NULL, 'A'}, #if O_BINARY     {"   binary", no_argument, NULL, 'B'},/
    /NULL, 'B'}, #endif     {GETOPT_   HELP_OPTION_DECL},     {GETOPT_/
    /NULL, 0}   };    program_name =   argv[0];   setlocale (LC_ALL, "");/
    /Number of characters preferably   read or written by each read and/
    /numbers = 1;    break;   case '   s':    ++options;    squeeze_empty/
    /numbers of this input file with   the corresponding values of the (/
    /numbers_at_empty_lines)       {   next_line_num ();         bpout =/
    /O, because otherwise      -b, -   s and -E would surprise users on/
    /of input was a       newline, a   line number may be written (/
    /of input, we       will have at   most (OUTSIZE - 1 + INSIZE * 4)/
    /one of these options, they don'   t care much about the original/
    /options;    mark_line_ends = 1;   break;   case 'T':    ++options;/
    /options;    mark_line_ends = 1;   quote = 1;    break;   case 'n':/
    /options;    quote = 1;    mark_   line_ends = 1;    output_tabs = 0;/
    /or modify    it under the terms   of the GNU General Public License/
    /otherwise call simple_cat to do   the actual work. */   int options/
    /outbuf = xmalloc (outsize - 1 +   insize * 4 + LINE_COUNTER_BUF_LEN)/
    /output in text mode, so that LF   causes   both CR and LF on output,/
    /output.\n\ \n\   -A, --show-all   equivalent to -vET\n\   -b, --/
    /output_tabs = 0;    break;  #if   O_BINARY  case 'B':    ++options;/
    /outsize, quote,         output_   tabs, numbers, numbers_at_empty_/
    /quoting, i.e. at least one of -   v, -e, or -t specified,   scan for/
    /read;    /* Determines how many   consecutive newlines there have/
    /requires seldom more than LINE_   COUNTER_BUF_LEN       positions.
    /returns EINVAL and        More/   BSD returns ENODEV on special/
    /show-all", no_argument, NULL, '   A'}, #if O_BINARY     {"binary",/
    /show-ends          display $ at   end of each line\n\   -n, --number/
    /show-nonprinting   use ^ and M-   notation, except for LFD and TAB\n/
    /show-nonprinting", no_argument,   NULL, 'v'},     {"show-ends", no_/
    /show them   those CR characters   as well, so make the input binary.
    /simple_cat (      /* Pointer to   the buffer, used by reads and/
    /so "cat > xyzzy" creates a DOS-   style text    file, like people/
    /so that BPIN > EOB, and thereby   input      is read immediately.
    /so that LF causes   both CR and   LF on output, and the output is/
    /st_ino == out_ino    && (input_   desc != STDIN_FILENO))  {    error/
    /st_mode))     {       out_dev =   stat_buf.st_dev;       out_ino =/
    /Stallman. */  #include <config.   h>  #include <stdio.h> #include </
    /stat_buf) < 0)     error (EXIT_   FAILURE, errno, _("standard output/
    /status = 1;         newlines2 =   newlines;         return;       }/
    /stdin = 0;    struct stat stat_   buf;    /* Variables that are set/
    /stdin is a terminal device, and   it is the ONLY    input file (i.e./
    /STDOUT_FILENO, O_TEXT);     } #   endif    /* Check if any of the/
    /sys/ioctl.h> #endif  #include "   system.h" #include "closeout.h" #/
    /t', '\0'   };  /* Position in `   line_buf' where printing starts.
    /t out_ino;    /* Nonzero if the   output file should not be the same/
    /terms of the GNU General Public   License as published by    the/
    /TEXT);        else   {     SET_   BINARY (input_desc); # ifdef __/
    /TEXT);     } #endif    /* Check   if any of the input files are the/
    /than other versions of cat, the   difference    is especially/
    /the checking should not be done   for those types,      and to allow/
    /the difference    is especially   apparent when using the -v option.
    /the given       options) as the   first thing in the output buffer./
    /to be substituted     by single   ditto (-s), and this was the/
    /to do the actual work. */   int   options = 0;    static struct/
    /to see the non-printables, let'   s show them   those CR characters/
    /to the console device.\n\n\ "),   stdout); #endif       printf (_("\/
    /tty_in)       __djgpp_set_ctrl_   c (1); # endif   }      } #endif/
    /types,      and to allow things   like cat < /dev/tty > /dev/tty,/
    /u,   --version, or --help) were   specified, use `cat', otherwise/
    /unsigned char ch;    /* Pointer   to the next character in the input/
    /v':    ++options;    quote = 1;   break;   case 'A':    ++options;/
    /valid byte in the input buffer,   i.e. the      current end of the/
    /version of `cat' to use. If any   options (more than -u,   --version/
    /versions of cat, the difference   is especially apparent when using/
    /with   the corresponding values   of the (output file associated/
    /write anything to the    output   yet), switch the output back to/
    /write error"));     } }  /* Cat   the file behind INPUT_DESC to the/
    /written (according to the given   options) as the first thing in the/
   !/    /int exit_status = 0;  void   usage (int status) {   if (status
   != n_/        */        if (full_   write (STDOUT_FILENO, buf, n_read)
   "/      */    while ((c = getopt_   long (argc, argv, #if O_BINARY
   "/    /);  }        free (inbuf);   contin:       if (!STREQ (infile,
   # endif   }/      */     if (tty_   in)       __djgpp_set_ctrl_c (1);
   #/      /use binary writes to the   console device.\n\n\ "), stdout);
   #/     /, advised by rms, Richard   Stallman. */  #include <config.h>
   #/    /|| errno == ENODEV # ifdef   ENOSYS         || errno == ENOSYS
   #/    /if (tty_in)       __djgpp_   set_ctrl_c (1); # endif   }      }
   $';         /* Output the/     */   if (mark_line_ends)   *bpout++ = '
   && !(numbers || squeeze_/      */   if ((!isatty (STDOUT_FILENO)
   &/    /&& stat_buf.st_dev == out_   dev && stat_buf.st_ino == out_ino
   (-s)/    /adjacent empty lines to   be substituted     by single ditto
   (/         display TAB characters   as ^I\n\   -u       /-T, --show-tabs
   (/       */    if (fstat (STDOUT_   FILENO, &stat_buf) < 0)     error
   (/       /appear in this block of   input, we       will have at most
   (/    /< argc);    if (have_read_   stdin && close (0) < 0)     error
   (/    /free (inbuf);      contin:   if (!STREQ (infile, "-") && close
   (0);/         */       file_open_   mode |= O_BINARY;       SET_BINARY
   (h) : (i))  /*/         */ #undef   max #define max(h,i) ((h) > (i) ?
   (i) ? (h) : (i))  /*/        */ #   undef max #define max(h,i) ((h) >
   (i))  /*/         */ #undef max #   define max(h,i) ((h) > (i) ? (h) :
   (numbers ||/          */   if ((!   isatty (STDOUT_FILENO)        && !
   (quote)/      */       file_open_   mode |= O_BINARY;     }   else if
   )/    /fprintf (stderr, _("Try `%   s --help' for more information.\n"
   );/     /, stdout);       fputs (   VERSION_OPTION_DESCRIPTION, stdout
   * Always unbuffered,/      */  /*   Differences from the Unix cat:
   */     if (ch == '\t' && !output_   tabs)   {     *bpout++ = '^';     /{
   */    /, call cat, otherwise call   simple_cat to do the actual work.
   */    /char *line_num_end = line_   buf + LINE_COUNTER_BUF_LEN - 3;  /
   *//    /if the output file should   not be the same as any input file.
   *endp = line_num_/     */  static   void next_line_num (void) {   char
   *eob = '\n/     */         bpin =   inbuf;        eob = bpin + n_read;
   , advised by rms, Richard/          By tege@sics.se, Torbjorn Granlund
   , n_read) != n_read)/          */   if (full_write (STDOUT_FILENO, buf
   ,/       /", no_argument, NULL, '   v'},     {"show-ends", no_argument
   ,/      /2;  #ifdef FIONREAD   /*   If nonzero, use the FIONREAD ioctl
   ,/    /N_ ("Torbjorn Granlund and   Richard M. Stallman")  /* Undefine
   ,/    /on others, so the checking   should not be done for those types
   .                   Input   files   cannot be redirected to themselves
   .         //* If nonzero, use the   FIONREAD ioctl, as an optimization
   .     /else  {    /* Not quoting,   neither of -v, -e, or -t specified
   /* Output/        */         if (   mark_line_ends)   *bpout++ = '$';
   /*/          */         if (mark_   line_ends)   *bpout++ = '$';
   /*/         */ #undef max #define   max(h,i) ((h) > (i) ? (h) : (i))
   /*/        /&& ioctl (input_desc,   FIONREAD, &n_to_read) < 0)   {
   /*/        bpout = stpcpy (bpout,   line_num_print);       }   }    /();
   /*/       if (++newlines > 0)   {   if (newlines >= 2)       {        */
   /*/     else   {     SET_BINARY (   input_desc); # ifdef __DJGPP__    /;
   /*/    /"error.h" #include "full-   write.h" #include "safe-read.h"
   /*/    /file"), infile);    exit_   status = 1;    goto contin;  }
   //     */       file_open_mode |=   O_BINARY;       SET_BINARY (0);
   //    /_output)      {        int   tty_in = isatty (input_desc);
   ;/    /input. */   int have_read_   stdin = 0;    struct stat stat_buf
   ?      /by single ditto (-s), and   this was the second empty     line
   \t' && !output_tabs)   {/      */   for (;;)      {        if (ch == '
   ^ and M- notation/    /(ignored)\   n\   -v, --show-nonprinting   use
   _("\/      /.\n"),       program_   name);   else     {       printf (
   _/       /if (use_fionread     &&   ioctl (input_desc, FIONREAD, &n_to
   _/     /int output_tabs,      int   numbers,      int numbers_at_empty
   _/    /)      {        char *wp =   outbuf;        do   {     if (full
   _/    /, O_TEXT);        else   {   SET_BINARY (input_desc); # ifdef _
   _/    //* Nonzero if we have ever   read standard input. */   int have
   _/    /_files  = 0;   int binary_   output = 0; #endif   int file_open
   _/    /ENOSYS         || errno ==   ENOSYS # endif         )       use
   _/    /more than one single blank   line\n\ "), stdout);       fputs (
   _/    /n_read = safe_read (input_   desc, inbuf, insize);        if (n
   _BINARY/           */    while ((   c = getopt_long (argc, argv, #if O
   _buf + LINE_COUNTER_BUF_/      */   static char *line_num_print = line
   _buf + LINE_COUNTER_BUF_/      */   static char *line_num_start = line
   _c (1); # endif   }/           */   if (tty_in)       __djgpp_set_ctrl
   _FILENO.               Copies the   file behind `input_desc' to STDOUT
   {         next_/     */      if (   numbers && numbers_at_empty_lines)
   {        char *wp =/           */   if (bpout - outbuf >= outsize)
   {"/    /, NULL, 'E'},     {"show-   tabs", no_argument, NULL, 'T'},
   {"/    /, NULL, 'v'},     {"show-   ends", no_argument, NULL, 'E'},
   {/          */    for (;;)      {   if (ch == '\t' && !output_tabs)
   {/     */       file_open_mode |=   O_BINARY;     }   else if (quote)
   {/     /*bpout++ = '^';         *   bpout++ = '?';       }     else
   {/    /_empty_lines || mark_line_   ends))       || binary_files)
   || errno/     */     if (errno ==   EOPNOTSUPP || errno == ENOTTY
   ||/           */   if ((!isatty (   STDOUT_FILENO)        && !(numbers
   ||/        /|| errno == EINVAL ||   errno == ENODEV # ifdef ENOSYS
   ||/     /&& !(numbers || squeeze_   empty_lines || mark_line_ends))
   }  #if O_/          */       out_   dev = 0;       out_ino = 0; #endif
   }/      /printf (_("\nReport bugs   to <%s>.\n"), PACKAGE_BUGREPORT);
   }/     /(outbuf, wp, bpout - wp);   bpout = outbuf + (bpout - wp);
   }/    /bpin = inbuf;        eob =   bpin + n_read;        *eob = '\n';
   + =/    /if (ch >= 128 + 32)    {   if (ch < 128 + 127)        *bpout+
   + LINE_/          */     outbuf =   xmalloc (outsize - 1 + insize * 4
   +;/       */         if (squeeze_   empty_lines)    {      ch = *bpin+
   ++/    /= 1;    numbers_at_empty_   lines = 0;    break;   case 'e':
   </    /contin:       if (!STREQ (   infile, "-") && close (input_desc)
   = '\/    /*bpout++ = '\n';      }   ch = *bpin++;  }       while (ch =
   = *bpin++;/       */         if (   squeeze_empty_lines)    {      ch
   = 0;/       /|| errno == ENOSYS #   endif         )       use_fionread
   = ENOTTY         || errno/     */   if (errno == EOPNOTSUPP || errno =
   = outbuf;    for/     */    eob =   inbuf;   bpin = eob + 1;    bpout
   =/     /(c)  {  case 0:    break;   case 'b':    ++options;    numbers
   =/    /. */    if (S_ISREG (stat_   buf.st_mode))     {       out_dev
   =/    /if (errno == EOPNOTSUPP ||   errno == ENOTTY         || errno =
   == out_/     */        if (check_   redirection    && stat_buf.st_dev
   >= 2)/          */         if (++   newlines > 0)   {     if (newlines
   0)     error (/        */    if (   fstat (STDOUT_FILENO, &stat_buf) <
   1); # endif   }/      */     if (   tty_in)       __djgpp_set_ctrl_c (
   1;    break;/        */    break;   case 'v':    ++options;    quote =
   1;/    /;    quote = 1;    break;   case 'A':    ++options;    quote =
   2 Free Software Foundation,/        Copyright (C) 88, 90, 91, 1995-200
   2)/        */       if (quote)  {   for (;;)      {        if (ch >= 3
   2/466,/       An 11 digit counter   may overflow within an hour on a P
   28/    /*bpout++ = 'M';         *   bpout++ = '-';         if (ch >= 1
   6,/       An 11 digit counter may   overflow within an hour on a P2/46
   a factor of 4 (by the/       Each   input character       may grow by
   advised by rms, Richard/       By   tege@sics.se, Torbjorn Granlund,
   advised by rms,/         By tege@   sics.se, Torbjorn Granlund,
   after/     /options) as the first   thing in the output buffer. (Done
   all buffered output/      If not,   we are about to wait,    so write
   an hour on a P2/466,/       An 11   digit counter may overflow within
   and/       /values of the (output   file associated with)   stdout,
   and/or/      This program is free   software; you can redistribute it
   appear in this block/      If all   characters do, and no newlines
   are at the beginning of a/          Initially 0 to indicate that we
   argv to/              */   char *   outbuf;    int c;    /* Index in
   argv, #if O_BINARY/            */   while ((c = getopt_long (argc,
   at the end of the buffer,/          A newline character is always put
   at/      /by    the Free Software   Foundation; either version 2, or (
   at/     /equivalent to -vE\n\   -   E, --show-ends          display $
   AUTHORS N_ ("/         */ #define   PROGRAM_NAME "cat"  #define
   AUTHORS N_ ("Torbjorn/       */ #   define PROGRAM_NAME "cat"  #define
   b,/     /lines' ends: then we use   text I/O, because otherwise      -
   B/    /input.\n\ "), stdout); #if   O_BINARY       fputs (_("\ \n\   -
   be interruptible.             But   we want terminal        reads to
   been read?)            (i.e. have   two or more consecutive newlines
   beginning of a/       Initially 0   to indicate that we are at the
   beginning of the/      */  static   void cat (      /* Pointer to the
   beginning of the/     */      int   insize,       /* Pointer to the
   beginning of/      Initially 0 to   indicate that we are at the
   beginning of/     */  static void   cat (      /* Pointer to the
   BINARY (0);/       */       file_   open_mode |= O_BINARY;       SET_
   BINARY (STDOUT_FILENO);/       */   binary_output = 1;       SET_
   BINARY/         */    while ((c =   getopt_long (argc, argv, #if O_
   BINARY/     */       out_dev = 0;   out_ino = 0; #endif     }  #if O_
   block of input was a/      If the   last character in the preceding
   block of input.                */   for (;;)     {       /* Read a
   both/     But keep console output   in text mode, so that LF causes
   bpin++;  }/          */         *   bpout++ = '\n';      }    ch = *
   bpout = outbuf + (bpout -/     */   memmove (outbuf, wp, bpout - wp);
   bpout = outbuf;    for (;/     */   eob = inbuf;   bpin = eob + 1;
   bpout =/     */         memmove (   outbuf, wp, bpout - wp);
   break;/     */    break;   case '   v':    ++options;    quote = 1;
   buf + LINE_COUNTER_BUF_/       */   static char *line_num_end = line_
   buf) < 0)     error (EXIT/     */   if (fstat (STDOUT_FILENO, &stat_
   buf, bufsize);       if (/     */   n_read = safe_read (input_desc,
   buf.st_dev == out_dev &&/      */   if (check_redirection    && stat_
   BUF_/       */ static char *line_   num_end = line_buf + LINE_COUNTER_
   buffer,/      A newline character   is always put at the end of the
   buffer.                  */   int   insize;    /* Pointer to the input
   buffer.               */   char *   inbuf;    /* Pointer to the output
   buffered output/       If not, we   are about to wait,    so write all
   buffered/          If not, we are   about to wait,    so write all
   bufsize);/           */        n_   read = safe_read (input_desc, buf,
   bufsize);/     */        n_read =   safe_read (input_desc, buf,
   by/      /* Are multiple adjacent   empty lines to be substituted    /2;
   byte/      */   char *bpin;    /*   Pointer to the first non-valid
   bytes/         After       output   is written, at most (OUTSIZE - 1)
   bytes/      After       output is   written, at most (OUTSIZE - 1)
   can redistribute it and/or/         This program is free software; you
   cat, the/               * Usually   much faster than other versions of
   causes/          But keep console   output in text mode, so that LF
   ch = *bpin++;/                 */   if (squeeze_empty_lines)    {
   char *endp = line_num_end/     */   static void next_line_num (void) {
   char *wp =/           */     if (   bpout - outbuf >= outsize)      {
   char *wp/      */     if (bpout -   outbuf >= outsize)      {
   character in/       */   unsigned   char ch;    /* Pointer to the next
   character/     */   unsigned char   ch;    /* Pointer to the next
   characters preferably/         */   char *buf,       /* Number of
   characters read by the/        */   char *bpout;    /* Number of
   characters read in each/       */   char *inbuf,       /* Number of
   characters read,/     */      int   bufsize) {   /* Actual number of
   characters written by/         */   char *outbuf,       /* Number of
   characters/        */      char *   inbuf,       /* Number of
   characters/        */      char *   outbuf,       /* Number of
   close_/    /(PACKAGE, LOCALEDIR);   textdomain (PACKAGE);    atexit (
   consecutive newlines, the/          Otherwise, with lots of
   consecutive/         */   ssize_t   n_read;    /* Determines how many
   consecutive/      */   ssize_t n_   read;    /* Determines how many
   Count of non-fatal error/      */   static int newlines2 = 0;  /*
   counter/     Otherwise, with lots   of     consecutive newlines, the
   COUNTER_BUF/     */ static char *   line_num_end = line_buf + LINE_
   COUNTER_BUF/     */ static char *   line_num_print = line_buf + LINE_
   COUNTER_BUF/     */ static char *   line_num_start = line_buf + LINE_
   COUNTER_BUF_/       A line number   requires seldom more than LINE_
   desc,/            */         if (   use_fionread     && ioctl (input_
   Descriptor on which input/     */   static char *infile;  /*
   details.           See the    GNU   General Public License for more
   determined by      NEWLINES/        The "state" of the procedure is
   determined by/              The "   state" of the procedure is
   display $ at end/      equivalent   to -vE\n\   -E, --show-ends      /-e
   display $ at/     equivalent to -   vE\n\   -E, --show-ends    /\n\   -e
   display $/     equivalent to -vE\   n\   -E, --show-ends       /\n\   -e
   display TAB/           equivalent   to -vT\n\   -T, --show-tabs      /-t
   display TAB/      equivalent to -   vT\n\   -T, --show-tabs    /("\   -t
   display/       equivalent to -vT\   n\   -T, --show-tabs      /_("\   -t
   do     {       if (argind/     */   infile = "-";   argind = optind;
   DOS-style text    file,/            This is so "cat > xyzzy" creates a
   each/    /to -vE\n\   -E, --show-   ends          display $ at end of
   else if (/         */       file_   open_mode |= O_BINARY;     }
   else if (quote)     {/         */   file_open_mode |= O_BINARY;     }
   empty_lines = 1;   int/        */   int numbers = 0;   int numbers_at_
   empty_lines = 1;/        */   int   numbers = 0;   int numbers_at_
   endif     }  #if O_BINARY/     */   out_dev = 0;       out_ino = 0; #
   endp = line_/     */  static void   next_line_num (void) {   char *
   ends/       /output lines\n\   -e   equivalent to -vE\n\   -E, --show-
   ENODEV on/          SunOS returns   EINVAL and        More/BSD returns
   ENOTTY         |/     */     if (   errno == EOPNOTSUPP || errno ==
   error (/        */    if (fstat (   STDOUT_FILENO, &stat_buf) < 0)
   factor of 4 (by/       Each input   character       may grow by a
   fatal error/        */ static int   newlines2 = 0;  /* Count of non-
   file should/      */   ino_t out_   ino;    /* Nonzero if the output
   file, like/     This is so "cat >   xyzzy" creates a DOS-style text
   file.                   */ char *   program_name;  /* Name of input
   file/    /output"));    outsize =   ST_BLKSIZE (stat_buf);   /* Input
   FILENO.           Copies the file   behind `input_desc' to STDOUT_
   FILENO/     */       if (isatty (   STDOUT_FILENO))  setmode (STDOUT_
   filesystems.)                 (On   Ultrix, it is not supported on NFS
   filesystems.)         (On Ultrix,   it is not supported on NFS
   filesystems.)      (On Ultrix, it   is not supported on NFS
   FIONREAD        int n_to_/     */   if (bpin > eob)      { #ifdef
   FIONREAD   /* If nonzero,/     */   int newlines = newlines2;  #ifdef
   FIONREAD   /* If/        */   int   newlines = newlines2;  #ifdef
   FIONREAD/     */         if (use_   fionread     && ioctl (input_desc,
   first non-valid byte in/       */   char *bpin;    /* Pointer to the
   for (;;)/      */    eob = inbuf;   bpin = eob + 1;    bpout = outbuf;
   for line numbers.              */   static int input_desc;  /* Buffer
   for more details.             See   the    GNU General Public License
   General Public/        You should   have received a copy of the GNU
   GNU General Public/           You   should have received a copy of the
   grow by a factor of 4 (by/          Each input character       may
   have values/          */      int   outsize,       /* Variables that
   HELP/    /{"binary", no_argument,   NULL, 'B'}, #endif     {GETOPT_
   hope that it will be useful/        This program is distributed in the
   hour on a P2/466/     An 11 digit   counter may overflow within an
   how many consecutive/          */   ssize_t n_read;    /* Determines
   i/o operations of input.       */   int outsize;    /* Optimal size of
   if (/         */    infile = "-";   argind = optind;    do     {
   if (/      {         *bpout++ = '   M';         *bpout++ = '-';    /else
   if (ch >= 32)   {     if/      */   if (quote)  {    for (;;)      {
   if (ch >= 32)/      */       if (   quote)  {    for (;;)      {
   If/           */   int newlines =   newlines2;  #ifdef FIONREAD   /*
   if/      */        n_read = safe_   read (input_desc, buf, bufsize);
   if/     */         n_read = safe_   read (input_desc, inbuf, insize);
   inbuf pointers are/      */   int   use_fionread = 1; #endif    /* The
   inbuf pointers/     */   int use_   fionread = 1; #endif    /* The
   inbuf, insize)/     */         n_   read = safe_read (input_desc,
   inbuf, insize);        if/     */   n_read = safe_read (input_desc,
   Index in argv to/              */   char *outbuf;    int c;    /*
   ino/       /&& stat_buf.st_dev ==   out_dev && stat_buf.st_ino == out_
   input buffer.                  */   int insize;    /* Pointer to the
   input file.                    */   char *program_name;  /* Name of
   input file/      */ static char *   infile;  /* Descriptor on which
   input_desc, FIONREAD, &n_/     */   if (use_fionread     && ioctl (
   insize * 4 + LINE_COUNTER/     */   outbuf = xmalloc (outsize - 1 +
   insize);/     */         n_read =   safe_read (input_desc, inbuf,
   insize,/           */        if (   options == 0)  {    insize = max (
   int n_to_/      */     if (bpin >   eob)      { #ifdef FIONREAD
   int n_to_read =/      */     if (   bpin > eob)      { #ifdef FIONREAD
   int numbers,      int/         */   int quote,      int output_tabs,
   int numbers,/         */      int   quote,      int output_tabs,
   int status) {   if/     */ static   int exit_status = 0;  void usage (
   int tty_in = isatty (/         */   if (binary_output)      {
   int/           */      int quote,   int output_tabs,      int numbers,
   int/        */   int numbers = 0;   int numbers_at_empty_lines = 1;
   interruptible.             But we   want terminal        reads to be
   interruptible.        But we want   terminal        reads to be
   is done when the/          A test   whether output needs to be written
   is/      /are initialized so that   BPIN > EOB, and thereby input
   isatty (/       */    if (binary_   output)      {        int tty_in =
   it/    /is free software; you can   redistribute it and/or modify
   larger/      This will not change   unless the number of lines is
   last/     */   char *bpout;    /*   Number of characters read by the
   LEN/       A line number requires   seldom more than LINE_COUNTER_BUF_
   License for more details.           See the    GNU General Public
   line numbers.           */ static   int input_desc;  /* Buffer for
   line/     /(PACKAGE);    atexit (   close_stdout);    /* Parse command
   line/     /in the preceding block   of input was a       newline, a
   line/    /*line_buf = '>';   if (   line_num_start < line_num_print)
   line?         /by single ditto (-   s), and this was the second empty
   line?      /by single ditto (-s),   and this was the second empty
   line_/      */  static void next_   line_num (void) {   char *endp =
   LINE_COUNTER_BUF_/      */ static   char *line_num_end = line_buf +
   LINE_COUNTER_BUF_/      */ static   char *line_num_print = line_buf +
   LINE_COUNTER_BUF_/      */ static   char *line_num_start = line_buf +
   LINE_COUNTER_BUF_LEN/      A line   number requires seldom more than
   lines is larger/        This will   not change    unless the number of
   lines is/           This will not   change    unless the number of
   lines)       {/                */   if (numbers && numbers_at_empty_
   M- notation/    /(ignored)\n\   -   v, --show-nonprinting   use ^ and
   MA 0/    /Foundation,    Inc., 59   Temple Place - Suite 330, Boston,
   many consecutive/     */   ssize_   t n_read;    /* Determines how
   max (insize, outsize);/        */   if (options == 0)  {    insize =
   mode disables/        By default,   switching console        to binary
   mode, so that LF causes/            But keep console output in text
   mode/    /}  #if O_BINARY   /* We   always read and write in BINARY
   more details.             See the   GNU General Public License for
   more/    //* Select which version   of `cat' to use. If any options (
   More/BSD returns ENODEV on/         SunOS returns EINVAL and
   most (OUTSIZE - 1) bytes/           After       output is written, at
   multiple adjacent empty/       */   newlines = 2;          /* Are
   n/    /.\n\n\ "), stdout); #endif   printf (_("\nReport bugs to <%s>.\
   n_read;        *eob = '\n/     */   bpin = inbuf;        eob = bpin +
   never more/    /number all output   lines\n\   -s, --squeeze-blank
   new/      Initially 0 to indicate   that we are at the beginning of a
   newline makes NEWLINES 1,/      0   newlines makes NEWLINES -1, 1
   newline/             */        /*   The loops below continue until a
   newline/         */        /* The   loops below continue until a
   newlines >= 2)       {/        */   if (++newlines > 0)   {     if (
   NEWLINES 1,/           0 newlines   makes NEWLINES -1, 1 newline makes
   NEWLINES 1,/     0 newlines makes   NEWLINES -1, 1 newline makes
   newlines appear in this/            If all       characters do, and no
   newlines appear in this/       If   all       characters do, and no
   newlines been read?)            (   i.e. have two or more consecutive
   newlines been read?)          (i.   e. have two or more consecutive
   newlines been read?)        (i.e.   have two or more consecutive
   newlines, the/         Otherwise,   with lots of     consecutive
   NEWLINES.             The "state"   of the procedure is determined by
   NEWLINES.          The "state" of   the procedure is determined by
   NEWLINES.      The "state" of the   procedure is determined by
   next/       */   char *eob;    /*   Pointer to the position where the
   next_/     */      if (numbers &&   numbers_at_empty_lines)       {
   next_line_num ();/             */   if (newlines >= 0 && numbers)  {
   next_line_num/     */        if (   newlines >= 0 && numbers)  {
   NFS filesystems.)               (   On Ultrix, it is not supported on
   non-fatal error/        */ static   int newlines2 = 0;  /* Count of
   non-valid byte/       */   char *   bpin;    /* Pointer to the first
   null/    /More/BSD returns ENODEV   on special files        like /dev/
   number of lines is larger/          This will not change    unless the
   number of lines is/          This   will not change    unless the
   number/       display $ at end of   each line\n\   -n, --number    /ends
   number/       equivalent to -vET\   n\   -b, --number-nonblank     /-all
   numbering,/            Exceptions   are when      they request line
   numbering,/        Exceptions are   when      they request line
   numbers.            */ static int   input_desc;  /* Buffer for line
   O/    /[1] == 0)  {    have_read_   stdin = 1;    input_desc = 0;  #if
   O_/    /, NULL, 'T'},     {"show-   all", no_argument, NULL, 'A'}, #if
   of -/    /ch = *bpin++;      }  }   else  {    /* Not quoting, neither
   of characters read, and/       */   int bufsize) {   /* Actual number
   of input was a/       If the last   character in the preceding block
   of the buffer, to/      A newline   character is always put at the end
   of the file.          */   ssize_   t n_read;    /* Loop until the end
   of the file.         */   ssize_t   n_read;    /* Loop until the end
   of the output.                 */   dev_t out_dev;    /* I-node number
   of these options, they don/     (   Besides, if they ask for      one
   on the standard output.        /*   cat -- concatenate files and print
   on/          SunOS returns EINVAL   and        More/BSD returns ENODEV
   on/        fstat on pipes returns   S_IFSOCK on some systems, S_IFIFO
   on/     fstat on pipes returns S_   IFSOCK on some systems, S_IFIFO
   operations of input/     */   int   outsize;    /* Optimal size of i/o
   options, they don'/     (Besides,   if they ask for      one of these
   options, they/       (Besides, if   they ask for      one of these
   or/        */   int argind;    /*   Device number of the output (file
   output (file or/         */   int   argind;    /* Device number of the
   output buffer.                 */   char *inbuf;    /* Pointer to the
   output file should/     */   ino_   t out_ino;    /* Nonzero if the
   output file/           */   ino_t   out_ino;    /* Nonzero if the
   output.           */   dev_t out_   dev;    /* I-node number of the
   output/      If not, we are about   to wait,    so write all buffered
   output/     /* cat -- concatenate   files and print on the standard
   OUTSIZE - 1) bytes/         After   output is written, at most (
   Pointer to the buffer,/        */   static void simple_cat (      /*
   position where the next/       */   char *eob;    /* Pointer to the
   preceding block of input/           If the last character in the
   preceding block of input/      If   the last character in the
   preferably/        */      char *   buf,       /* Number of characters
   processed/     */   char *outbuf;   int c;    /* Index in argv to
   Public/           You should have   received a copy of the GNU General
   quote = 1;    break;/          */   break;   case 'v':    ++options;
   read by the last/     */   char *   bpout;    /* Number of characters
   read) != n_/       */        if (   full_write (STDOUT_FILENO, buf, n_
   read?)             (i.e. have two   or more consecutive newlines been
   read?)          (i.e. have two or   more consecutive newlines been
   redistribute it and/or/      This   program is free software; you can
   redistribute it/     This program   is free software; you can
   redistribute/     This program is   free software; you can
   remain/    /output is written, at   most (OUTSIZE - 1) bytes will
   request line numbering,/            Exceptions are when      they
   returns ENODEV on/          SunOS   returns EINVAL and        More/BSD
   Richard/         By tege@sics.se,   Torbjorn Granlund, advised by rms,
   rms, Richard/       By tege@sics.   se, Torbjorn Granlund, advised by
   s/    /adjacent empty lines to be   substituted     by single ditto (-
   S_IFIFO/           fstat on pipes   returns S_IFSOCK on some systems,
   SET_BINARY (0);        /*/     */   file_open_mode |= O_BINARY;
   setmode (/         */        if (   tty_in && optind <= argc)
   setmode (STDOUT_FILENO, O/     */   if (isatty (STDOUT_FILENO))
   setmode (STDOUT_FILENO, O/     */   if (tty_in && optind <= argc)
   so that LF causes   both/     But   keep console output in text mode,
   so write all buffered/              If not, we are about to wait,
   Software/             Copyright (   C) 88, 90, 91, 1995-2002 Free
   some systems, S_IFIFO/              fstat on pipes returns S_IFSOCK on
   specified.                 Called   if any option more than -u was
   specified.              Called if   any option more than -u was
   st_dev == out/     */        if (   check_redirection    && stat_buf.
   standard output.        /* cat --   concatenate files and print on the
   stat_/    /is not done for device   files either. */    if (S_ISREG (
   status) {   if/     */ static int   exit_status = 0;  void usage (int
   status)/      */ static int exit_   status = 0;  void usage (int
   stdout)/    /use binary writes to   the console device.\n\n\ "),
   stdout); #/    /use binary writes   to the console device.\n\n\ "),
   STDOUT_/         */       binary_   output = 1;       SET_BINARY (
   STDOUT_/       */        if (tty_   in && optind <= argc)   setmode (
   STDOUT_FILENO,/     */       if (   isatty (STDOUT_FILENO))  setmode (
   STDOUT_FILENO.             Copies   the file behind `input_desc' to
   style text    file,/         This   is so "cat > xyzzy" creates a DOS-
   style text    file,/      This is   so "cat > xyzzy" creates a DOS-
   systems, S_IFIFO/           fstat   on pipes returns S_IFSOCK on some
   systems, S_IFIFO/        fstat on   pipes returns S_IFSOCK on some
   TAB/    /equivalent to -vT\n\   -   T, --show-tabs          display
   text    file,/       This is so "   cat > xyzzy" creates a DOS-style
   TEXT/    /if (tty_in && optind <=   argc)   setmode (STDOUT_FILENO, O_
   than LINE_COUNTER_BUF_LEN/          A line number requires seldom more
   than LINE_COUNTER_BUF_LEN/      A   line number requires seldom more
   that have values/              */   int outsize,       /* Variables
   that it will be useful,/     This   program is distributed in the hope
   that LF causes/          But keep   console output in text mode, so
   the beginning of the/          */   int insize,       /* Pointer to
   the buffer,/      */  static void   simple_cat (      /* Pointer to
   the counter/      Otherwise, with   lots of     consecutive newlines,
   the end of the buffer, to/      A   newline character is always put at
   the end of the file.           */   ssize_t n_read;    /* Loop until
   the file.         */   ssize_t n_   read;    /* Loop until the end of
   the GNU General Public/             You should have received a copy of
   The inbuf pointers are/        */   int use_fionread = 1; #endif    /*
   the next character in the/     */   unsigned char ch;    /* Pointer to
   the output (file or/           */   int argind;    /* Device number of
   the output file should/        */   ino_t out_ino;    /* Nonzero if
   the output.             */   dev_   t out_dev;    /* I-node number of
   the output.            */   dev_t   out_dev;    /* I-node number of
   the/               * Usually much   faster than other versions of cat,
   the/        A test whether output   needs to be written is done when
   the/     /if (mark_line_ends)   *   bpout++ = '$';         /* Output
   themselves.                 Input   files cannot be redirected to
   they don't/     (Besides, if they   ask for      one of these options,
   they/       (Besides, if they ask   for      one of these options,
   this block/      */        if (n_   read == 0)  break;        /* Write
   to be interruptible.                But we want terminal        reads
   to binary mode disables/            By default, switching console
   to binary mode disables/       By   default, switching console
   to the beginning of the/       */   static void cat (      /* Pointer
   to the buffer,/        */  static   void simple_cat (      /* Pointer
   to themselves.                      Input   files cannot be redirected
   to/    /newlines = 2;          /*   Are multiple adjacent empty lines
   Torbjorn/     */ #define PROGRAM_   NAME "cat"  #define AUTHORS N_ ("
   tty_in = isatty (/     */    if (   binary_output)      {        int
   usage (int status) {   if/     */   static int exit_status = 0;  void
   v'/    /, NULL, 's'},     {"show-   nonprinting", no_argument, NULL, '
   v, -e, or -t/        */        /*   If quoting, i.e. at least one of -
   versions of cat, the/           *   Usually much faster than other
   vET\/    /output.\n\ \n\   -A, --   show-all           equivalent to -
   warning/    /= 0; #ifdef lint  /*   Suppress `used before initialized'
   was a/      If the last character   in the preceding block of input
   was specified.                      Called if any option more than -u
   when the/          A test whether   output needs to be written is done
   where a/     /-b, -s and -E would   surprise users on DOS/Windows
   where the next/       */   char *   eob;    /* Pointer to the position
   which input file/       */ static   char *infile;  /* Descriptor on
   will be useful,/     This program   is distributed in the hope that it
   will be/          This program is   distributed in the hope that it
   within an hour on a P2/466,/        An 11 digit counter may overflow
   write all buffered output/     If   not, we are about to wait,    so
   Write this block out.          */   if (n_read == 0)  break;        /*
   Write this/        */        if (   n_read == 0)  break;        /*
   writes/      /fputs (_("\ \n\   -   B, --binary             use binary
   written is done when the/           A test whether output needs to be
   written is done when the/       A   test whether output needs to be
