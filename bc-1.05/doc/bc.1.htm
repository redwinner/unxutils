                            <!-- manual page source format generated by PolyglotMan v3.0.7, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>bc(1) manual page</TITLE>
</HEAD>
<BODY bgcolor=white>
<A HREF="#toc">Table of Contents</A><P>
 
<H2><A NAME="sect0" HREF="#toc0">Name </A></H2>
bc - An arbitrary precision calculator 
language  
<H2><A NAME="sect1" HREF="#toc1">Syntax </A></H2>
<B>bc </B> [ <B>-lwsqv </B> ] [long-options] [ <I> file ... </I> ]  
<H2><A NAME="sect2" HREF="#toc2">Version </A></H2>
This 
man page documents GNU bc version 1.04.  
<H2><A NAME="sect3" HREF="#toc3">Description </A></H2>
<B>bc </B> is a language that 
supports arbitrary precision numbers with interactive execution of statements. 
 There are some similarities in the syntax to the C programming language. 
 A standard math library is available by command line option. If requested, 
the math library is defined before processing any files. <B>bc </B> starts by 
processing code from all the files listed on the command line in the order 
listed.  After all files have been processed, <B>bc </B> reads from the standard 
input.  All code is executed as it is read.  (If a file contains a command 
to halt the processor, <B>bc </B> will never read from the standard input.) <P>
This 
version of <B>bc </B> contains several extensions beyond traditional <B>bc </B> implementations 
and the POSIX draft standard. Command line options can cause these extensions 
to print a warning  or to be rejected.  This  document describes the language 
accepted by this processor. Extensions will be identified as such.  
<H3><A NAME="sect4" HREF="#toc4">Options 
</A></H3>

<DL>

<DT>-l </DT>
<DD>Define the standard math library. </DD>

<DT>-w </DT>
<DD>Give warnings for extensions to POSIX 
<B>bc </B>. </DD>

<DT>-s </DT>
<DD>Process exactly the POSIX <B>bc </B> language. </DD>

<DT>-q </DT>
<DD>Do not print the normal 
GNU bc welcome. </DD>

<DT>-v </DT>
<DD>Print the version number and copyright and quit. </DD>

<DT>--mathlib 
</DT>
<DD>Define the standard math library. </DD>

<DT>--warn </DT>
<DD>Give warnings for extensions to 
POSIX <B>bc </B>. </DD>

<DT>--standard </DT>
<DD>Process exactly the POSIX <B>bc </B> language. </DD>

<DT>--quiet </DT>
<DD>Do not 
print the normal GNU bc welcome. </DD>

<DT>--version </DT>
<DD>Print the version number and copyright 
and quit. </DD>
</DL>
 
<H3><A NAME="sect5" HREF="#toc5">Numbers </A></H3>
The most basic element in <B>bc </B> is the number.  Numbers 
are arbitrary precision numbers.  This precision is both in the integer 
part and the fractional part.  All numbers are represented internally in 
decimal and all computation is done in decimal.  (This version truncates 
results from divide and multiply operations.)  There are two attributes 
of numbers, the length and the scale.  The length is the total number of 
significant decimal digits in a number and the scale is the total number 
of decimal digits after the decimal point.  For example:  <BR>
 <PRE>  .000001 has a length of 6 and scale of 6. 
  1935.000 has a length of 7 and a scale of 3. 
   </PRE> 
<H3><A NAME="sect6" HREF="#toc6">Variables </A></H3>
Numbers are stored in two types of variables, simple variables 
and arrays.  Both simple variables and array variables are named.  Names 
begin with a letter followed by any number of letters, digits and underscores. 
 All letters must be lower case.  (Full alpha-numeric names are an extension. 
In POSIX <B>bc </B> all names are a single lower case letter.)  The type of variable 
is clear by the context because all array variable names will be followed 
by brackets ([]). <P>
There are four special variables, <B>scale, ibase, obase, 
</B> and <B>last </B>.  <B>scale </B> defines how some operations use digits after the decimal 
point.  The default value of <B>scale </B> is 0. <B>ibase </B> and <B>obase </B> define the conversion 
base for input and output numbers.  The default for both input and output 
is base 10. <B>last </B> (an extension) is a variable that has the value of the 
last printed number.  These will be discussed in further detail where appropriate. 
 All of these variables may have values assigned to them as well as used 
in expressions.  
<H3><A NAME="sect7" HREF="#toc7">Comments </A></H3>
Comments in <B>bc </B> start with the characters <B>/* 
</B> and end with the characters <B>*/ </B>.  Comments may start anywhere and appear 
as a single space in the input.  (This causes comments to delimit other 
input items.  For example, a comment can not be found in the middle of 
a variable name.)  Comments include any newlines (end of line) between 
the start and the end of the comment. <P>
To support the use of scripts for 
<B>bc </B>, a single line comment has been added as an extension.  A single line 
comment starts at a <B># </B> character and continues to the next end of the 
line.  The end of line character is not part of the comment and is processed 
normally.  
<H3><A NAME="sect8" HREF="#toc8">Expressions </A></H3>
The numbers are manipulated by expressions and statements. 
 Since the language was designed to be interactive, statements and expressions 
are executed as soon as possible.  There is no "main" program.  Instead, 
code is executed as it is encountered.  (Functions, discussed in detail 
later, are defined when encountered.) <P>
A simple expression is just a constant. 
<B>bc </B> converts constants into internal decimal numbers using the current 
input base, specified by the variable <B>ibase </B>. (There is an exception in 
functions.) The legal values of <B>ibase </B> are 2 through 16.  Assigning a value 
outside this range to <B>ibase </B> will result in a value of 2 or 16.  Input 
numbers may contain the characters 0-9 and A-F. (Note: They must be capitals. 
 Lower case letters are variable names.) Single digit numbers always have 
the value of the digit regardless of the value of <B>ibase </B>. (i.e. A = 10.)  
For multi-digit numbers, <B>bc </B> changes all input digits greater or equal 
to ibase to the value of <B>ibase </B>-1.  This makes the number <B>FFF </B> always be 
the largest 3 digit number of the input base. <P>
Full expressions are similar 
to many other high level languages. Since there is only one kind of number, 
there are no rules for mixing types.  Instead, there are rules on the scale 
of expressions.  Every expression has a scale.  This is derived from the 
scale of original numbers, the operation performed and in many cases, 
the value of the variable <B>scale </B>. Legal values of the variable <B>scale </B> are 
0 to the maximum number representable by a C integer. <P>
In the following 
descriptions of legal expressions, "expr" refers to a complete expression 
and "var" refers to a simple or an array variable. A simple variable is 
just a  <blockquote><I>name </I>  </blockquote>
and an array variable is specified as  <blockquote><I>name </I>[<I>expr </I>]  </blockquote>
Unless 
specifically mentioned the scale of the result is the maximum scale of 
the expressions involved. 
<DL>

<DT>- expr </DT>
<DD>The result is the negation of the expression. 
</DD>

<DT>++ var </DT>
<DD>The variable is incremented by one and the new value is the result 
of the expression. </DD>

<DT>-- var </DT>
<DD>The variable is decremented by one and the new 
value is the result of the expression. </DD>

<DT>var ++ </DT>
<DD> The result of the expression 
is the value of the variable and then the variable is incremented by one. 
</DD>

<DT>var -- </DT>
<DD>The result of the expression is the value of the variable and then 
the variable is decremented by one. </DD>

<DT>expr + expr </DT>
<DD>The result of the expression 
is the sum of the two expressions. </DD>

<DT>expr - expr </DT>
<DD>The result of the expression 
is the difference of the two expressions. </DD>

<DT>expr * expr </DT>
<DD>The result of the 
expression is the product of the two expressions. </DD>

<DT>expr / expr </DT>
<DD>The result 
of the expression is the quotient of the two expressions. The scale of 
the result is the value of the variable <B>scale </B>. </DD>

<DT>expr % expr </DT>
<DD>The result 
of the expression is the "remainder" and it is computed in the following 
way.  To compute a%b, first a/b is computed to <B>scale </B> digits.  That result 
is used to compute a-(a/b)*b to the scale of the maximum of <B>scale </B>+scale(b) 
and scale(a).  If <B>scale </B> is set to zero and both expressions are integers 
this expression is the integer remainder function. </DD>

<DT>expr ^ expr </DT>
<DD>The result 
of the expression is the value of the first raised to the second. The second 
expression must be an integer.  (If the second expression is not an integer, 
a warning is generated and the expression is truncated to get an integer 
value.)  The scale of the result is <B>scale </B> if the exponent is negative. 
 If the exponent is positive the scale of the result is the minimum of 
the scale of the first expression times the value of the exponent and 
the maximum of <B>scale </B> and the scale of the first expression.  (e.g. scale(a^b) 
= min(scale(a)*b, max( <B>scale, </B> scale(a))).)  It should be noted that expr^0 
will always return the value of 1. </DD>

<DT>( expr ) </DT>
<DD>This alters the standard precedence 
to force the evaluation of the expression. </DD>

<DT>var = expr </DT>
<DD>The variable is assigned 
the value of the expression. </DD>

<DT>var &lt;op&gt;= expr </DT>
<DD>This is equivalent to "var = 
var &lt;op&gt; expr" with the exception that the "var" part is evaluated only 
once.  This can make a difference if "var" is an array. </DD>
</DL>
<P>
 Relational expressions 
are a special kind of expression that always evaluate to 0 or 1, 0 if 
the relation is false and 1 if the relation is true.  These may appear 
in any legal expression. (POSIX bc requires that relational expressions 
are used only in if, while, and for statements and that only one relational 
test may be done in them.)  The relational operators are 
<DL>

<DT>expr1 &lt; expr2 </DT>
<DD>The 
result is 1 if expr1 is strictly less than expr2. </DD>

<DT>expr1 &lt;= expr2 </DT>
<DD>The result 
is 1 if expr1 is less than or equal to expr2. </DD>

<DT>expr1 &gt; expr2 </DT>
<DD>The result is 
1 if expr1 is strictly greater than expr2. </DD>

<DT>expr1 &gt;= expr2 </DT>
<DD>The result is 
1 if expr1 is greater than or equal to expr2. </DD>

<DT>expr1 == expr2 </DT>
<DD>The result 
is 1 if expr1 is equal to expr2. </DD>

<DT>expr1 != expr2 </DT>
<DD>The result is 1 if expr1 
is not equal to expr2. </DD>
</DL>
<P>
Boolean operations are also legal.  (POSIX <B>bc </B> does 
NOT have boolean operations). The result of all boolean operations are 
0 and 1 (for false and true) as in relational expressions.  The boolean 
operators are: 
<DL>

<DT>!expr </DT>
<DD>The result is 1 if expr is 0. </DD>

<DT>expr &amp;&amp; expr </DT>
<DD>The result 
is 1 if both expressions are non-zero. </DD>

<DT>expr || expr </DT>
<DD>The result is 1 if either 
expression is non-zero. </DD>
</DL>
<P>
The expression precedence is as follows: (lowest 
to highest)  <BR>
 <PRE> || operator, left associative 
 &amp;&amp; operator, left associative 
 ! operator, nonassociative 
 Relational operators, left associative 
 Assignment operator, right associative 
 + and - operators, left associative 
 *, / and % operators, left associative 
 ^ operator, right associative 
 unary - operator, nonassociative 
 ++ and -- operators, nonassociative 
   </PRE><P>
This precedence was chosen so that POSIX compliant <B>bc </B> programs will 
run correctly. This will cause the use of the relational and logical operators 
to have some unusual behavior when used with assignment expressions.  Consider 
the expression:  <blockquote>a = 3 &lt; 5  </blockquote>
<P>
Most C programmers would assume this would 
assign the result of "3 &lt; 5" (the value 1) to the variable "a".  What this 
does in <B>bc </B> is assign the value 3 to the variable "a" and then compare 
3 to 5.  It is best to use parenthesis when using relational and logical 
operators with the assignment operators. <P>
There are a few more special expressions 
that are provided in <B>bc </B>. These have to do with user defined functions 
and standard functions.  They all appear as "<I><A HREF="s">name<B>(<I>parameters<B>)</A>
 </B></I></B></I>". See the 
section on functions for user defined functions.  The standard functions 
are: 
<DL>

<DT>length ( expression ) </DT>
<DD>The value of the length function is the number 
of significant digits in the expression. </DD>

<DT>read ( ) </DT>
<DD>The read function (an 
extension) will read a number from the standard input, regardless of where 
the function occurs.   Beware, this can cause problems with the mixing 
of data and program in the standard input. The best use for this function 
is in a previously written program that needs input from the user, but 
never allows program code to be input from the user.  The value of the 
read function is the number read from the standard input using the current 
value of the variable  <B>ibase </B> for the conversion base. </DD>

<DT>scale ( expression 
) </DT>
<DD>The value of the scale function is the number of digits after the decimal 
point in the expression. </DD>

<DT>sqrt ( expression ) </DT>
<DD>The value of the sqrt function 
is the square root of the expression.  If the expression is negative, a 
run time error is generated. </DD>
</DL>
 
<H3><A NAME="sect9" HREF="#toc9">Statements </A></H3>
Statements (as in most algebraic 
languages) provide the sequencing of expression evaluation.  In <B>bc </B> statements 
are executed "as soon as possible."  Execution happens when a newline in 
encountered and there is one or more complete statements.  Due to this 
immediate execution, newlines are very important in <B>bc </B>. In fact, both 
a semicolon and a newline are used as statement separators.  An improperly 
placed newline will cause a syntax error.  Because newlines are statement 
separators, it is possible to hide a newline by using the backslash character. 
 The sequence "\&lt;nl&gt;", where &lt;nl&gt; is the newline appears to <B>bc </B> as whitespace 
instead of a newline.  A statement list is a series of statements separated 
by semicolons and newlines.  The following is a list of <B>bc </B> statements 
and what they do: (Things enclosed in brackets ([]) are optional parts 
of the statement.) 
<DL>

<DT>expression </DT>
<DD>This statement does one of two things.  If 
the expression starts with "&lt;variable&gt; &lt;assignment&gt; ...", it is considered to 
be an assignment statement.  If the expression is not an assignment statement, 
the expression is evaluated and printed to the output.  After the number 
is printed, a newline is printed.  For example, "a=1" is an assignment 
statement and "(a=1)" is an expression that has an embedded assignment. 
 All numbers that are printed are printed in the base specified by the 
variable <B>obase </B>. The legal values for <B> obase </B> are 2 through BC_BASE_MAX. 
 (See the section LIMITS.)  For bases 2 through 16, the usual method of 
writing numbers is used.  For bases greater than 16, <B>bc </B> uses a multi-character 
digit method of printing the numbers where each higher base digit is printed 
as a base 10 number.  The multi-character digits are separated by spaces. 
Each digit contains the number of characters required to represent the 
base ten value of "obase-1".  Since numbers are of arbitrary precision, 
some numbers may not be printable on a single output line. These long numbers 
will be split across lines using the "\" as the last character on a line. 
 The maximum number of characters printed per line is 70.  Due to the interactive 
nature of <B>bc </B> printing a number cause the side effect of assigning the 
printed value the the special variable <B>last </B>. This allows the user to recover 
the last value printed without having to retype the expression that printed 
the number.  Assigning to <B>last </B> is legal and will overwrite the last printed 
value with the assigned value.  The newly assigned value will remain until 
the next number is printed or another value is assigned to <B>last </B>.  (Some 
installations may allow the  use of a single period (.) which is not part 
of a number as a short hand notation for for <B>last </B>.) </DD>

<DT>string </DT>
<DD>The string 
is printed to the output.  Strings start with a double quote character 
and contain all characters until the next double quote character. All characters 
are take literally, including any newline.  No newline character is printed 
after the string. </DD>

<DT><B>print </B> list </DT>
<DD>The print statement (an extension) provides 
another method of output. The "list" is a list of strings and expressions 
separated by commas. Each string or expression is printed in the order 
of the list.  No terminating newline is printed.  Expressions are evaluated 
and their value is printed and assigned the the variable <B>last </B>. Strings 
in the print statement are printed to the output and may contain special 
characters.  Special characters start with the backslash character (\).  
The special characters recognized by <B>bc </B> are "a" (alert or bell), "b" 
(backspace), "f" (form feed), "n" (newline), "r" (carriage return), "q" 
(double quote), "t" (tab), and "\" (backslash). Any other character following 
the backslash will be ignored.   </DD>

<DT>{ statement_list } </DT>
<DD>This is the compound 
statement.  It allows multiple statements to be grouped together for execution. 
</DD>

<DT><B>if </B> ( expression ) statement1 [<B>else </B> statement2] </DT>
<DD>The if statement evaluates 
the expression and executes statement1 or statement2 depending on the 
value of the expression.  If the expression is non-zero, statement1 is executed. 
 If statement2 is present and the value of the expression is 0, then statement2 
is executed.  (The else clause is an extension.) </DD>

<DT><B>while </B> ( expression ) statement 
</DT>
<DD>The while statement will execute the statement while the expression is 
non-zero.  It evaluates the expression before each execution of the statement. 
  Termination of the loop is caused by a zero expression value or the 
execution of a break statement. </DD>

<DT><B>for </B> ( [expression1] ; [expression2] ; 
[expression3] ) statement </DT>
<DD>The for statement controls repeated execution 
of the statement.   Expression1 is evaluated before the loop.  Expression2 
is evaluated before each execution of the statement.  If it is non-zero, 
the statement is evaluated.  If it is zero, the loop is terminated.  After 
each execution of the statement, expression3 is evaluated before the reevaluation 
of expression2.  If expression1 or expression3 are missing, nothing is 
evaluated at the point they would be evaluated. If expression2 is missing, 
it is the same as substituting the value 1 for expression2.  (The optional 
expressions are an extension. POSIX <B>bc </B> requires all three expressions.) 
The following is equivalent code for the for statement:  <BR>
 <PRE> expression1; 
 while (expression2) { 
    statement; 
    expression3; 
 } 
   </PRE>
<DL>

<DT><B>break </B> </DT>
<DD>This statement causes a forced exit of the most recent enclosing 
while statement or for statement. </DD>

<DT><B>continue </B> </DT>
<DD>The continue statement (an 
extension)  causes the most recent enclosing for statement to start the 
next iteration. </DD>

<DT><B>halt </B> </DT>
<DD>The halt statement (an extension) is an executed 
statement that causes the <B>bc </B> processor to quit only when it is executed. 
 For example, "if (0 == 1) halt" will not cause <B>bc </B> to terminate because 
the halt is not executed. </DD>

<DT><B>return </B> </DT>
<DD>Return the value 0 from a function.  (See 
the section on functions.) </DD>

<DT><B>return </B> ( expression ) </DT>
<DD>Return the value of the 
expression from a function.  (See the section on  functions.) </DD>
</DL>
 
<H3><A NAME="sect10" HREF="#toc10">Pseudo Statements 
</A></H3>
These statements are not statements in the traditional sense.  They are 
not executed statements.  Their function is performed at "compile" time. 

<DL>

<DT><B>limits </B> </DT>
<DD>Print the local limits enforced by the local version of <B>bc </B>.  This 
is an extension. </DD>

<DT><B>quit </B> </DT>
<DD>When the quit statement is read, the <B>bc </B> processor 
is terminated, regardless of where the quit statement is found.  For example, 
"if (0 == 1) quit" will cause <B>bc </B> to terminate. </DD>

<DT><B>warranty </B> </DT>
<DD>Print a longer 
warranty notice.  This is an extension. </DD>
</DL>
 
<H3><A NAME="sect11" HREF="#toc11">Functions </A></H3>
Functions provide a method 
of defining a computation that can be executed later.  Functions in  <B>bc</B> 
always compute a value and return it to the caller.  Function definitions 
are "dynamic" in the sense that a function is undefined until a definition 
is encountered in the input.  That definition is then used until another 
definition function for the same name is encountered.  The new definition 
then replaces the older definition.  A function is defined as follows: 
 <BR>
 <PRE> define name ( parameters ) { newline 
     auto_list   statement_list }  
   </PRE>A function call is just an expression of the form "<I><A HREF="s">name<B>(<I>parameters<B>)</A>
 
</B></I></B></I>". <P>
Parameters are numbers or arrays (an extension).  In the function definition, 
zero or more parameters are defined by listing their names separated by 
commas.  Numbers are only call by value parameters.  Arrays are only call 
by variable.  Arrays are specified in the parameter definition by the notation 
"<I>name<B>[] </B></I>".   In the function call, actual parameters are full expressions 
for number parameters.  The same notation is used for passing arrays as 
for defining array parameters.  The named array is passed by variable to 
the function.  Since function definitions are dynamic, parameter numbers 
and types are checked when a function is called.  Any mismatch in number 
or types of parameters will cause a runtime error. A runtime error will 
also occur for the call to an undefined function. <P>
The <I>auto_list </I> is an 
optional list of variables that are for "local" use.  The syntax of the 
auto list (if present) is "<B>auto <I>name </I></B>, ... ;".  (The semicolon is optional.) 
 Each <I>name </I> is the name of an auto variable.  Arrays may be specified by 
using the same notation as used in parameters.  These variables have their 
values pushed onto a stack at the start of the function.  The variables 
are then initialized to zero and used throughout the execution of the 
function.  At function exit, these variables are popped so that the original 
value (at the time of the function call) of these variables are restored. 
 The parameters are really auto variables that are initialized to a value 
provided in the function call.  Auto variables are different than traditional 
local variables in the fact that if function A calls function B, B may 
access function A's auto variables by just using the same name, unless 
function B has called them auto variables.  Due to the fact that auto variables 
and parameters are pushed onto a stack, <B>bc </B> supports recursive functions. 
<P>
The function body is a list of <B>bc </B> statements.  Again, statements are separated 
by semicolons or newlines.  Return statements cause the termination of 
a function and the return of a value.  There are two versions of the return 
statement.  The first form, "<B>return </B>", returns the value 0 to the calling 
expression.  The second form,  "<B>return ( <I>expression <B>) </B></I></B>", computes the value 
of the expression and returns that value to the calling expression.  There 
is an implied "<B>return (0) </B>" at the end of every function.  This allows 
a function to terminate and return 0 without an explicit return statement. 
<P>
Functions also change the usage of the variable <B>ibase </B>.  All constants 
in the function body will be converted using the value of <B>ibase </B> at the 
time of the function call.  Changes of <B>ibase </B> will be ignored during the 
execution of the function except for the standard function <B>read </B>, which 
will always use the current value of <B>ibase </B> for conversion of numbers. 
 
<H3><A NAME="sect12" HREF="#toc12">Math Library </A></H3>
If <B>bc </B> is invoked with the <B>-l </B> option, a math library is 
preloaded and the default scale is set to 20.   The math functions will 
calculate their results to the scale set at the time of their call.   The 
math library defines the following functions: 
<DL>

<DT>s (<I>x </I>) </DT>
<DD>The sine of x, x 
is in radians. </DD>

<DT>c (<I>x </I>) </DT>
<DD>The cosine of x, x is in radians. </DD>

<DT>a (<I>x </I>) </DT>
<DD>The arctangent 
of x, arctangent returns radians. </DD>

<DT>l (<I>x </I>) </DT>
<DD>The natural logarithm of x. </DD>

<DT>e (<I>x 
</I>) </DT>
<DD>The exponential function of raising e to the value x. </DD>

<DT>j (<I>n,x </I>) </DT>
<DD>The bessel 
function of integer order n of x. </DD>
</DL>
 
<H3><A NAME="sect13" HREF="#toc13">Examples </A></H3>
In /bin/sh,  the following 
will assign the value of "pi" to the shell variable <B>pi </B>.  <blockquote>CW pi=$(echo 
"scale=10; 4*<A HREF="s">a(1)</A>
" | bc -l)    </blockquote>
<P>
The following is the definition of the exponential 
function used in the math library.  This function is written in POSIX <B>bc 
</B>.  <BR>
 <PRE> CW 
 scale = 20 
   
  /* Uses the fact that e^x = (e^(x/2))^2 
    When x is small enough, we use the series: 
      e^x = 1 + x + x^2/2! + x^3/3! + ... 
 */ 
   
  define e(x) { 
   auto  a, d, e, f, i, m, v, z 
   
    /* Check the sign of x. */ 
   if (x&lt;0) { 
     m = 1 
     x = -x 
   }  
   
    /* Precondition x. */ 
   z = scale; 
   scale = 4 + z + .44*x; 
   while (x &gt; 1) { 
     f += 1; 
     x /= 2; 
   } 
   
    /* Initialize the variables. */ 
   v = 1+x 
   a = x 
   d = 1 
   
    for (i=2; 1; i++) { 
     e = (a *= x) / (d *= i) 
     if (e == 0) { 
       if (f&gt;0) while (f--)  v = v*v; 
       scale = z 
       if (m) return (1/v); 
       return (v/1); 
     } 
     v += e 
   } 
 } 
   
   </PRE><P>
The following is code that uses the extended features of <B>bc </B> to implement 
a simple program for calculating checkbook balances.  This program is best 
kept in a file so that it can be used many times  without having to retype 
it at every use.  <BR>
 <PRE> CW 
 scale=2 
 print "\nCheck book program!\n" 
 print "  Remember, deposits are negative transactions.\n" 
 print "  Exit by a 0 transaction.\n\n" 
   
  print "Initial balance? "; bal = read() 
 bal /= 1 
 print "\n" 
 while (1) { 
   "current balance = "; bal 
   "transaction? "; trans = read() 
   if (trans == 0) break; 
   bal -= trans 
   bal /= 1 
 } 
 quit 
   
   </PRE><P>
The following is the definition of the recursive factorial function. 
 <BR>
 <PRE> CW 
 define f (x) { 
   if (x &lt;= 1) return (1); 
   return (f(x-1) * x); 
 } 
   
   </PRE> 
<H3><A NAME="sect14" HREF="#toc14">Readline Option </A></H3>
GNU <B>bc </B> can be compiled (via a configure option) to 
use the GNU <B>readline </B> input editor library.  This allows the user to do 
more editing of lines before sending them to <B>bc </B>. It also allows for a 
history of previous lines typed.  When this option is selected, <B>bc </B> has 
one more special variable. This special variable, <B>history </B> is the number 
of lines of history retained.  A value of -1 means that an unlimited number 
of history lines are retained.  This is the default value. Setting the value 
of <B>history </B> to a positive number restricts the number of history lines 
to the number given.  The value of 0 disables the history feature.  For 
more information, read the user manuals for the GNU <B>readline </B> and <B>history 
</B> libraries.  
<H3><A NAME="sect15" HREF="#toc15">Differences </A></H3>
This version of  <B>bc</B> was implemented from the POSIX 
P1003.2/D11 draft and contains several differences and extensions relative 
to the draft and traditional implementations. It is not implemented in 
the traditional way using <I><A HREF="s">dc(1)</A>
.</I> This version is a single process which 
parses and runs a byte code translation of the program.  There is an "undocumented" 
option (-c) that causes the program to output the byte code to the standard 
output instead of running it.  It was mainly used for debugging the parser 
and preparing the math library. <P>
A major source of differences is extensions, 
where a feature is extended to add more functionality and additions, where 
new features are added.  The following is the list of differences and extensions. 

<DL>

<DT>LANG </DT>
<DD>This version does not conform to the POSIX standard in the processing 
of the LANG environment variable and all environment variables starting 
with LC_. </DD>

<DT>names </DT>
<DD>Traditional and POSIX <B>bc</B> have single letter names for functions, 
variables and arrays.  They have been extended to be multi-character names 
that start with a letter and may contain letters, numbers and the underscore 
character. </DD>

<DT>Strings </DT>
<DD>Strings are not allowed to contain NUL characters.  POSIX 
says all characters must be included in strings. </DD>

<DT>last </DT>
<DD>POSIX <B>bc </B> does not 
have a <B>last </B> variable.  Some implementations of <B>bc </B> use the period (.) in 
a similar way.   </DD>

<DT>comparisons </DT>
<DD>POSIX <B>bc </B> allows comparisons only in the if 
statement, the while statement, and the second expression of the for statement. 
 Also, only one relational operation is allowed in each of those statements. 
</DD>

<DT>if statement, else clause </DT>
<DD>POSIX <B>bc </B> does not have an else clause. </DD>

<DT>for statement 
</DT>
<DD>POSIX <B>bc </B> requires all expressions to be present in the for statement. 
</DD>

<DT>&amp;&amp;, ||, ! </DT>
<DD>POSIX <B>bc </B> does not have the logical operators. </DD>

<DT>read function </DT>
<DD>POSIX 
<B>bc </B> does not have a read function. </DD>

<DT>print statement </DT>
<DD>POSIX <B>bc </B> does not have 
a print statement . </DD>

<DT>continue statement </DT>
<DD>POSIX <B>bc </B> does not have a continue 
statement. </DD>

<DT>array parameters </DT>
<DD>POSIX <B>bc </B> does not (currently) support array 
parameters in full. The POSIX grammar allows for arrays in function definitions, 
but does not provide a method to specify an array as an actual parameter. 
 (This is most likely an oversight in the grammar.)  Traditional implementations 
of <B>bc </B> have only call by value array parameters. </DD>

<DT>=+, =-, =*, =/, =%, =^ </DT>
<DD>POSIX 
<B>bc </B> does not require these "old style" assignment operators to be defined. 
 This version may allow these "old style" assignments.  Use the limits 
statement to see if the installed version supports them.  If it does support 
the "old style" assignment operators, the statement "a =- 1" will decrement 
<B>a </B> by 1 instead of setting <B>a </B> to the value -1. </DD>

<DT>spaces in numbers </DT>
<DD>Other implementations 
of <B>bc </B> allow spaces in numbers.  For example, "x=1 3" would assign the 
value 13 to the variable x.  The same statement would cause a syntax error 
in this version of <B>bc </B>. </DD>

<DT>errors and execution </DT>
<DD>This implementation varies 
from other implementations in terms of what code will be executed when 
syntax and other errors are found in the program.  If a syntax error is 
found in a function definition, error recovery tries to find the beginning 
of a statement and continue to parse the function.  Once a syntax error 
is found in the function, the function will not be callable and becomes 
undefined. Syntax errors in the interactive execution code will invalidate 
the current execution block.  The execution block is terminated by an end 
of line that appears after a complete sequence of statements. For example, 
  <BR>
 <PRE> a = 1 
 b = 2 
   </PRE>has two execution blocks and  <BR>
 <PRE> { a = 1 
   b = 2 } 
   </PRE>has one execution block.  Any runtime error will terminate the execution 
of the current execution block.  A runtime warning will not terminate the 
current execution block. 
<DL>

<DT>Interrupts </DT>
<DD>During an interactive session, the 
SIGINT signal (usually generated by the control-C character from the terminal) 
will cause execution of the current execution block to be interrupted. 
 It will display a "runtime" error indicating which function was interrupted. 
 After all runtime structures have been cleaned up, a message will be 
printed to notify the user that <B>bc </B> is ready for more input.  All previously 
defined functions remain defined and the value of all non-auto variables 
are the value at the point of interruption.  All auto variables and function 
parameters are removed during the clean up process.  During a non-interactive 
session, the SIGINT signal will terminate the entire run of <B>bc </B>. </DD>
</DL>
 
<H3><A NAME="sect16" HREF="#toc16">Limits 
</A></H3>
The following are the limits currently in place for this  <B>bc</B> processor. 
 Some of them may have been changed by an installation. Use the limits 
statement to see the actual values. 
<DL>

<DT>BC_BASE_MAX </DT>
<DD>The maximum output base 
is currently set at 999.  The maximum input base is 16. </DD>

<DT>BC_DIM_MAX </DT>
<DD>This 
is currently an arbitrary limit of 65535 as distributed.  Your installation 
may be different. </DD>

<DT>BC_SCALE_MAX </DT>
<DD>The number of digits after the decimal point 
is limited to INT_MAX digits. Also, the number of digits before the decimal 
point is limited to INT_MAX digits. </DD>

<DT>BC_STRING_MAX </DT>
<DD>The limit on the number 
of characters in a string is INT_MAX characters. </DD>

<DT>exponent </DT>
<DD>The value of 
the exponent in the raise operation (^) is limited to LONG_MAX. </DD>

<DT>multiply 
</DT>
<DD>The multiply routine may yield incorrect results if a number has more 
than LONG_MAX / 90 total digits.  For 32 bit longs, this number is 23,860,929 
digits. </DD>

<DT>code size </DT>
<DD>Each function and the "main" program are limited to 16384 
bytes of compiled byte code each.  This limit (BC_MAX_SEGS) can be easily 
changed to have more than 16 segments of 1024 bytes. </DD>

<DT>variable names </DT>
<DD>The 
current limit on the number of unique names is 32767 for each of simple 
variables, arrays and functions. </DD>
</DL>
 
<H2><A NAME="sect17" HREF="#toc17">Environment Variables </A></H2>
The following environment 
variables are processed by <B>bc </B>: 
<DL>

<DT>POSIXLY_CORRECT </DT>
<DD>This is the same as the 
<B>-s </B> option. </DD>

<DT>BC_ENV_ARGS </DT>
<DD>This is another mechanism to get arguments to <B>bc 
</B>.  The format is the same as the command line arguments.  These arguments 
are processed first, so any files listed in the environent arguments are 
processed before any command line argument files.  This allows the user 
to set up "standard" options and files to be processed at every invocation 
of <B>bc </B>.  The files in the environment variables would typically contain 
function definitions for functions the user wants defined every time <B>bc 
</B> is run. </DD>

<DT>BC_LINE_LENGTH </DT>
<DD>This should be an integer specifing the number 
of characters in an output line for numbers. This includes the backslash 
and newline characters for long numbers. </DD>
</DL>
 
<H2><A NAME="sect18" HREF="#toc18">Files </A></H2>
In most installations, 
<B>bc </B> is completely self-contained. Where executable size is of importance 
or the C compiler does not deal with very long strings, <B>bc </B> will read 
the standard math library from the file /usr/local/lib/libmath.b. (The actual 
location may vary.  It may be /lib/libmath.b.)  
<H2><A NAME="sect19" HREF="#toc19">Diagnostics </A></H2>
If any file on 
the command line can not be opened, <B>bc </B> will report that the file is unavailable 
and terminate.  Also, there are compile and run time diagnostics that should 
be self-explanatory.  
<H2><A NAME="sect20" HREF="#toc20">Bugs </A></H2>
Error recovery is not very good yet. <P>
Email bug 
reports to <B>bug-gnu-utils@prep.ai.mit.edu</B>. Be sure to include the word ``bc'' somewhere 
in the ``Subject:'' field.  
<H2><A NAME="sect21" HREF="#toc21">Author </A></H2>
 <BR>
 <PRE>Philip A. Nelson 
 phil@cs.wwu.edu 
  </PRE> 
<H2><A NAME="sect22" HREF="#toc22">Acknowledgements </A></H2>
The author would like to thank Steve Sommars (Steve.Sommars@att.com) 
for his extensive help in testing the implementation.  Many great suggestions 
were given.  This is a much better product due to his involvement. <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">Name</A></LI>
<LI><A NAME="toc1" HREF="#sect1">Syntax</A></LI>
<LI><A NAME="toc2" HREF="#sect2">Version</A></LI>
<LI><A NAME="toc3" HREF="#sect3">Description</A></LI>
<UL>
<LI><A NAME="toc4" HREF="#sect4">Options</A></LI>
<LI><A NAME="toc5" HREF="#sect5">Numbers</A></LI>
<LI><A NAME="toc6" HREF="#sect6">Variables</A></LI>
<LI><A NAME="toc7" HREF="#sect7">Comments</A></LI>
<LI><A NAME="toc8" HREF="#sect8">Expressions</A></LI>
<LI><A NAME="toc9" HREF="#sect9">Statements</A></LI>
<LI><A NAME="toc10" HREF="#sect10">Pseudo Statements</A></LI>
<LI><A NAME="toc11" HREF="#sect11">Functions</A></LI>
<LI><A NAME="toc12" HREF="#sect12">Math Library</A></LI>
<LI><A NAME="toc13" HREF="#sect13">Examples</A></LI>
<LI><A NAME="toc14" HREF="#sect14">Readline Option</A></LI>
<LI><A NAME="toc15" HREF="#sect15">Differences</A></LI>
<LI><A NAME="toc16" HREF="#sect16">Limits</A></LI>
</UL>
<LI><A NAME="toc17" HREF="#sect17">Environment Variables</A></LI>
<LI><A NAME="toc18" HREF="#sect18">Files</A></LI>
<LI><A NAME="toc19" HREF="#sect19">Diagnostics</A></LI>
<LI><A NAME="toc20" HREF="#sect20">Bugs</A></LI>
<LI><A NAME="toc21" HREF="#sect21">Author</A></LI>
<LI><A NAME="toc22" HREF="#sect22">Acknowledgements</A></LI>
</UL>
</BODY></HTML>
